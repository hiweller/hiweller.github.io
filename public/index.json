[{"authors":null,"categories":null,"content":" There are fascinating ideas all over the place, irresistible experiments beyond numbering, all sorts of new ways into the maze of problems. But every next move is unpredictable, every outcome uncertain. It is a puzzling time, but a very good time.\nI do not know how you lay out orderly plans for this kind of activity, but I suppose you could find out by looking through the disorderly records of the past hundred years. Somehow, the atmosphere has to be set so that a disquieting sense of being wrong is the normal attitude of the investigators. It has to be taken for granted that the only way in is by riding the unencumbered human imagination, with the special rigor required for recognizing that something can be highly improbable, maybe almost impossible, and at the same time true.\n ‚ÄîLewis Thomas, on basic science\nWe are constantly inventing new ways to represent organisms as numbers \u0026ndash; genomics, CT scanning, 3D kinematics, molecular phylogenetics, fMRIs, neural networks, and anything else that falls under the label of \u0026ldquo;big data\u0026rdquo;.These methods allow researchers to address important, qualitative questions in specific, quantitative ways. This comes with a major caveat: representing organisms as numbers, however comprehensive we try to make those numbers, reduces the organisms. What are we losing? What matters, and to whom?\nIn the broadest possible sense, my ambitions as a biologist are 1) to figure out how we can choose the right numbers for our questions, 2) to use those numbers to answer those questions in meaningful ways, and 3) to always keep our answers in context of the full complexity of the organisms themselves, warts and all.\n  Download my CV.\n","date":1554595200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/author/hannah-weller/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/hannah-weller/","section":"authors","summary":"There are fascinating ideas all over the place, irresistible experiments beyond numbering, all sorts of new ways into the maze of problems. But every next move is unpredictable, every outcome uncertain.","tags":null,"title":"Hannah Weller","type":"authors"},{"authors":null,"categories":null,"content":"Âê≥ÊÅ©ÈÅî is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"da99cb196019cc5857b9b3e950397ca9","permalink":"/author/%E5%90%B3%E6%81%A9%E9%81%94/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/%E5%90%B3%E6%81%A9%E9%81%94/","section":"authors","summary":"Âê≥ÊÅ©ÈÅî is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.","tags":null,"title":"Âê≥ÊÅ©ÈÅî","type":"authors"},{"authors":null,"categories":null,"content":"   Table of Contents  What you will learn Program overview Courses in this program Meet your instructor FAQs    What you will learn  Fundamental Python programming skills Statistical concepts and how to apply them in practice Gain experience with the Scikit, including data visualization with Plotly and data wrangling with Pandas  Program overview The demand for skilled data science practitioners is rapidly growing. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi.\nCourses in this program  Python basics Build a foundation in Python.   Visualization Learn how to visualize data with Plotly.   Statistics Introduction to statistics for data science.   Meet your instructor Hannah Weller FAQs Are there prerequisites? There are no prerequisites for the first course.\n How often do the courses run? Continuously, at your own pace.\n  Begin the course   ","date":1611446400,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1611446400,"objectID":"59c3ce8e202293146a8a934d37a4070b","permalink":"/courses/example/","publishdate":"2021-01-24T00:00:00Z","relpermalink":"/courses/example/","section":"courses","summary":"An example of using Wowchemy's Book layout for publishing online courses.","tags":null,"title":"üìä Learn Data Science","type":"book"},{"authors":null,"categories":null,"content":"Build a foundation in Python.\n  1-2 hours per week, for 8 weeks\nLearn   Quiz What is the difference between lists and tuples? Lists\n Lists are mutable - they can be changed Slower than tuples Syntax: a_list = [1, 2.0, 'Hello world']  Tuples\n Tuples are immutable - they can\u0026rsquo;t be changed Tuples are faster than lists Syntax: a_tuple = (1, 2.0, 'Hello world')   Is Python case-sensitive? Yes\n","date":1609459200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609459200,"objectID":"17a31b92253d299002593b7491eedeea","permalink":"/courses/example/python/","publishdate":"2021-01-01T00:00:00Z","relpermalink":"/courses/example/python/","section":"courses","summary":"Build a foundation in Python.\n","tags":null,"title":"Python basics","type":"book"},{"authors":null,"categories":null,"content":"Learn how to visualize data with Plotly.\n  1-2 hours per week, for 8 weeks\nLearn   Quiz When is a heatmap useful? Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n Write Plotly code to render a bar chart import plotly.express as px data_canada = px.data.gapminder().query(\u0026quot;country == 'Canada'\u0026quot;) fig = px.bar(data_canada, x='year', y='pop') fig.show()  ","date":1609459200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609459200,"objectID":"1b341b3479c8c6b1f807553b77e21b7c","permalink":"/courses/example/visualization/","publishdate":"2021-01-01T00:00:00Z","relpermalink":"/courses/example/visualization/","section":"courses","summary":"Learn how to visualize data with Plotly.\n","tags":null,"title":"Visualization","type":"book"},{"authors":null,"categories":null,"content":"Introduction to statistics for data science.\n  1-2 hours per week, for 8 weeks\nLearn The general form of the normal probability density function is:\n$$ f(x) = \\frac{1}{\\sigma \\sqrt{2\\pi} } e^{-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2} $$\n The parameter $\\mu$ is the mean or expectation of the distribution. $\\sigma$ is its standard deviation. The variance of the distribution is $\\sigma^{2}$.   Quiz What is the parameter $\\mu$? The parameter $\\mu$ is the mean or expectation of the distribution.\n","date":1609459200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609459200,"objectID":"6f4078728d71b1b791d39f218bf2bdb1","permalink":"/courses/example/stats/","publishdate":"2021-01-01T00:00:00Z","relpermalink":"/courses/example/stats/","section":"courses","summary":"Introduction to statistics for data science.\n","tags":null,"title":"Statistics","type":"book"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.   Slides can be added in a few ways:\n Create slides using Wowchemy\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further event details, including page elements such as image galleries, can be added to the body of this page.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"a8edef490afe42206247b6ac05657af0","permalink":"/talk/example-talk/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example-talk/","section":"event","summary":"An example talk using Wowchemy's Markdown slides feature.","tags":[],"title":"Example Talk","type":"event"},{"authors":[],"categories":[],"content":"A quick reference gallery for what the most broadly useful functions do.\nLoading and pre-processing images  readImage: Reads in a PNG or JPEG image, optionally resizing and/or rotating it.  img \u0026lt;- system.file(\u0026quot;extdata/corbetti.png\u0026quot;, package = \u0026quot;recolorize\u0026quot;) loaded_image \u0026lt;- readImage(img_path = img, resize = NULL, rotate = NULL)   blurImage: Applies one of several blurring filters from the imager package to a loaded image. Helpful for dealing with variation from textures (e.g. scales, reflections, hairs, etc).  blurred_image \u0026lt;- blurImage(loaded_image, blur_function = \u0026quot;medianblur\u0026quot;, n = 3, threshold = 5)  Initial segmentation  recolorize: The major function of the package. Segments colors using color binning (method = \u0026quot;hist\u0026quot;) or k-means clustering (method = \u0026quot;k\u0026quot;), in several color spaces.  rc_hist \u0026lt;- recolorize(img, method = \u0026quot;hist\u0026quot;, bins = 2, color_space = \u0026quot;sRGB\u0026quot;) #\u0026gt; #\u0026gt; Using 2^3 = 8 total bins  rc_k \u0026lt;- recolorize(img, method = \u0026quot;k\u0026quot;, n = 8, color_space = \u0026quot;sRGB\u0026quot;)   recolorize2: Runs recolorize and recluster (see next section) in sequence. I have found this to be an effective, fast combination for very many kinds of images, so if you\u0026rsquo;re going to pick one function to start with, pick this one!  rc \u0026lt;- recolorize2(img, cutoff = 45) #\u0026gt; #\u0026gt; Using 2^3 = 8 total bins   imposeColors: Imposes colors from one image onto another image (useful for batch processing).  colors \u0026lt;- c(\u0026quot;tomato\u0026quot;, \u0026quot;limegreen\u0026quot;, \u0026quot;dodgerblue\u0026quot;, \u0026quot;cornsilk\u0026quot;, \u0026quot;black\u0026quot;) colors \u0026lt;- t(col2rgb(colors)) / 255 imposed \u0026lt;- imposeColors(img, centers = colors)  Refining initial results  recluster: Combines existing clusters based on either a cutoff for color similarity or a target number of colors.  recluster_fit \u0026lt;- recluster(rc_hist, similarity_cutoff = 45)   thresholdRecolor: Drops the smallest clusters from a recolorize fit and refits the original image.  rc_thresh \u0026lt;- thresholdRecolor(rc_hist, pct = 0.01)   wernerColor: Remaps a recolorize object to the colors in Werner\u0026rsquo;s Nomenclature of Colors by Patrick Syme (1821), one of the first attempts at an objective color reference in western science, notably used by Charles Darwin. This one is mostly just for fun.  rc_werner \u0026lt;- wernerColor(recluster_fit)  Minor edits  absorbLayer: \u0026ldquo;Absorbs\u0026rdquo; all or part of a layer into the surrounding colors, optionally according to a size or location condition.  absorb_red \u0026lt;- absorbLayer(recluster_fit, layer_idx = 3, size_condition = function(s) s \u0026lt;= 100, highlight_color = \u0026quot;cyan\u0026quot;)   editLayer/editLayers: Applies one of several morphological operations from imager to a layer (or layers) of a recolorize object. This can be used to despeckle, fill in holes, or uniformly grow or shrink a color patch.  rc_edit \u0026lt;- editLayer(absorb_red, layer_idx = 3, operation = \u0026quot;fill\u0026quot;, px_size = 2)   mergeLayers: Merges specified layers together, with options for setting the new color.  merged_rc \u0026lt;- mergeLayers(rc_hist, merge_list = list(c(4, 7), c(3, 5), c(6, 8)))  Visualization  plotImageArray: Plots a 1D or 3D array as an RGB image.  layout(matrix(1:4, nrow = 1)) plotImageArray(loaded_image, main = \u0026quot;original\u0026quot;) plotImageArray(loaded_image[ , , 1], main = \u0026quot;red\u0026quot;) plotImageArray(loaded_image[ , , 2], main = \u0026quot;green\u0026quot;) plotImageArray(loaded_image[ , , 3], main = \u0026quot;blue\u0026quot;)   imDist | imHeatmap: Compares two versions of the same image by calculating the color distance between the colors of each pair of pixels (imDist), and gives you a few more options for plotting the results (imHeatmap).  layout(matrix(1:2, nrow = 1)) par(mar = rep(0, 4)) im_dist \u0026lt;- imDist(im1 = raster_to_array(recluster_fit$original_img), im2 = recoloredImage(recluster_fit), color_space = \u0026quot;Lab\u0026quot;) imHeatmap(im_dist, palette = viridisLite::viridis(100), legend = FALSE)   plotColorClusters: Plots color clusters in a 3D color space.  par(mar = rep(1, 4)) plotColorClusters(recluster_fit$centers, recluster_fit$sizes, color_space = \u0026quot;sRGB\u0026quot;, xlab = \u0026quot;red\u0026quot;, ylab = \u0026quot;green\u0026quot;, zlab = \u0026quot;blue\u0026quot;)   plotColorPalette: Alternatively, just plot as a color palette.  par(mar = rep(0, 4)) plotColorPalette(recluster_fit$centers, recluster_fit$sizes)  Exporting to other packages or files  splitByColor: Separates color clusters into individual layers (binary masks).  layout(matrix(1:6, nrow = 1)) plotImageArray(rc_edit$original_img) corbetti_layers \u0026lt;- splitByColor(rc_edit, plot_method = \u0026quot;over\u0026quot;)    classify_recolorize: Converts a recolorize object to a classify object in the pavo package for linking with spectral data.\n  recolorize_adjacency: Converts to a classify object using the above function, then runs the adjacency and boundary strength analysis function using values for human perceptual similarity.\n  recolorizeVector: Converts a bitmap (i.e. pixel) image to a vector image.\n  rc_vector \u0026lt;- recolorizeVector(recluster_fit, size_filter = 0.15, smoothness = 5)  ","date":1618272000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1618349229,"objectID":"6e384bde14a838a46df235e779e0354c","permalink":"/post/function-gallery-for-recolorize/","publishdate":"2021-04-13T00:00:00Z","relpermalink":"/post/function-gallery-for-recolorize/","section":"post","summary":"A quick reference gallery for what the most broadly useful functions do.\nLoading and pre-processing images  readImage: Reads in a PNG or JPEG image, optionally resizing and/or rotating it.  img \u0026lt;- system.","tags":["recolorize","color","r packages"],"title":"Function gallery for recolorize","type":"post"},{"authors":[],"categories":[],"content":"color-based image segmentation (for people with other things to do)  You can also tour the functions in the function gallery.\n The recolorize package is a toolbox for making color maps, essentially color-based image segmentation, using a combination of automatic, semi-automatic, and manual procedures. It has four major goals:\n  Provide a middle ground between automatic segmentation methods (which are hard to modify when they don\u0026rsquo;t work well) and manual methods (which can be slow and subjective).\n  Be deterministic whenever possible, so that you always get the same results from the same code.\n  Be modular and modifiable, so that you can tailor it for your purposes.\n  Play nice with other color analysis tools.\n  The color map above, for example, was generated using a single function which runs in a few seconds (and is deterministic):\nlibrary(recolorize) # get the path to the image (comes with the package, so we use system.file): img \u0026lt;- system.file(\u0026quot;extdata/corbetti.png\u0026quot;, package = \u0026quot;recolorize\u0026quot;) # fit a color map (only provided parameter is a color similarity cutoff) recolorize_obj \u0026lt;- recolorize2(img, cutoff = 45)  Notice what we didn‚Äôt have to input: we didn‚Äôt have to declare how many colors we expected (5), what we expect those colors to be (red, green, blue, black, and white), which pixels to include in each color patch, or where the boundaries of those patches are.\nThis introduction is intended to get you up and running with the recolorize package. Ideally, after reading it, you will have enough information to start to play around with the set of tools that it provides in a way that suits what you need it to do.\nI have tried not to assume too much about the reader\u0026rsquo;s background knowledge and needs, except that you are willing to use R and you have a color segmentation problem you have to solve before you can do something interesting with images. I primarily work with images of animals (beetles, fish, lizards, butterflies, snakes, birds, etc), and that will probably come through in the documentation. But it should work just as well for other kinds of images. Maybe better!\nI hope that this package will be helpful to you, and that if it is, you will share it with others who might find it helpful too. I had a lot of fun discussions with a lot of interesting people while I was making it, for which I\u0026rsquo;m very grateful.\nIf something is unclear or you find a bug, please get in touch or file an issue on the GitHub page. Suggestions for improvements are always welcome!\nQuick start  The bare minimum to start toying around with the package.\n The basic recolorize workflow is initial clustering step \\(\\rightarrow\\) refinement step \\(\\rightarrow\\) manual tweaks.\n  Images should first be color-corrected and have any background masked out, ideally with transparency, as in the image above, for example (Chrysochroa corbetti, taken by Nathan P. Lord, used with permission and egregiously downsampled to ~250x150 pixels by me).\n  In the initial clustering step, we bin all of the pixels into (in this case) 8 total clusters:\n  init_fit \u0026lt;- recolorize(img, method = \u0026quot;hist\u0026quot;, bins = 2, color_space = \u0026quot;sRGB\u0026quot;) #\u0026gt; #\u0026gt; Using 2^3 = 8 total bins  Followed by a refinement step where we combine clusters by their similarity:  refined_fit \u0026lt;- recluster(init_fit, similarity_cutoff = 45)  # pretty big improvement!  The recolorize2 function above calls these functions in sequence, since they tend to be pretty effective in combination.\nFinally, we can do manual refinements to clean up the different color layers, for example absorbing the red speckles into the surrounding color patches:  absorb_red \u0026lt;- absorbLayer(refined_fit, layer_idx = 3, size_condition = function(s) s \u0026lt;= 15, highlight_color = \u0026quot;cyan\u0026quot;)  Or performing simple morphological operations on individual layers:\nfinal_fit \u0026lt;- editLayer(absorb_red, 3, operation = \u0026quot;fill\u0026quot;, px_size = 4)  You can also batch process images using the same parameters, although recolorize functions only deal with one image at a time, so you will have to use a for loop or define a new function to call the appropriate functions in the right order:\n# get all 5 beetle images: images \u0026lt;- dir(system.file(\u0026quot;extdata\u0026quot;, package = \u0026quot;recolorize\u0026quot;), \u0026quot;png\u0026quot;, full.names = TRUE) # make an empty list to store the results: rc_list \u0026lt;- vector(\u0026quot;list\u0026quot;, length = length(images)) # run `recolorize2` on each image # you would probably want to add more sophisticated steps in here as well, but you get the idea for (i in 1:length(images)) { rc_list[[i]] \u0026lt;- suppressMessages(recolorize2(images[i], bins = 2, cutoff = 30, plotting = FALSE)) } # plot for comparison: layout(matrix(1:10, nrow = 2)) for (i in rc_list) { plotImageArray(i$original_img) plotImageArray(recoloredImage(i)) }  # given the variety of colors in the dataset, not too bad, # although you might go in and refine these individually  Once you have a color map you\u0026rsquo;re happy with, you can export to a variety of formats. For instance, if I wanted to run Endler\u0026rsquo;s adjacency and boundary strength analysis in the pavo package, using human perception:\nadj \u0026lt;- recolorize_adjacency(rc_list[[1]], coldist = \u0026quot;default\u0026quot;, hsl = \u0026quot;default\u0026quot;) #\u0026gt; Using single set of coldists for all images. #\u0026gt; Using single set of hsl values for all images. print(adj[ , c(57:62)]) # just print the chromatic and achromatic boundary strength values #\u0026gt; m_dS s_dS cv_dS m_dL s_dL cv_dL #\u0026gt; 36.33178 11.90417 0.3276517 24.88669 17.80173 0.7153115  If you\u0026rsquo;d like a deeper explanation of each of these steps, as well as how to modify them to suit your needs, along with what else the package can do: read on!\nBefore you start Color segmentation can be a real rabbit hole‚Äîthat is, it can be pretty easy to become fixated on getting perfect results, or on trying to define some objective standard for what correct segmentation looks like. The problem with this mindset is that there‚Äôs no set of universal parameters that will give you perfect segmentation results for every image, because images alone don‚Äôt always contain all the relevant information: color variation due to poor lighting in one image could be just as distinct as color variation due to pattern striations in another.\nThe correct output for color segmentation depends on your goal: are you concerned with identifying regions of structural vs. pigmented color? Does the intensity of the stain on your slide matter, or just presence/absence? If you have a few dozen stray pixels of the wrong color in an image with hundreds of thousands of correctly categorized pixels, will that meaningfully affect your calculations?\nLet\u0026rsquo;s take the jewel beetle (family Buprestidae) images that come with the package as an example. If I want to segment the lefthand image (Chrysochroa fulgidissima), the solution depends on my question. If my question is \u0026ldquo;How does the placement and size of these red bands compare to that of closely related beetles?\u0026rdquo; then I really just want to separate the red bands from the rest of the body, so I would want the color map in the middle. If my question is \u0026ldquo;How much do these red bands stand out from the iridescent green base of the beetle?\u0026rdquo; then I care about the brighter orange borders of the bands, because these increase the boundary strength and overall contrast in the beetle\u0026rsquo;s visual appearance‚Äîso I would go with map 2 on the right. So before you start, I highly recommend writing down precisely what you want to measure at the end of your analysis, to avoid becoming weighed down by details that may not matter. It will save you a lot of time.\nStep 0: Image acquisition \u0026amp; preparation  What to do before you use recolorize.\n Before we attempt image segmentation, we need segmentable images. recolorize doesn‚Äôt process your images for you beyond a few basic things like resizing, rotating, and blurring (which can help with segmentation). You should do all image processing steps which are usually necessary for getting quantitative color data, like white balance correction, gradient correction, or background removal, before inputting them to recolorize.\nThere are lots of software tools available for making these kinds of corrections: GIMP, FIJI/ImageJ, and even the imager package will provide options for some or all of these. If you really want to get pipeline-y, Python has a much more robust set of image processing libraries that will help with automatic color correction and background masking, which is well beyond the scope of this intro.\nIf you are at all concerned with sensory biology and animal vision, I highly recommend micaToolbox, which is a well-documented and comprehensive toolkit for creating images as animals see them (rather than as cameras and computers see them); see especially the instructions for creating false color cone-mapped images.\nThe corrections you have to make really depend on what you‚Äôre trying to do. If you just care about the regions but don‚Äôt really care about the final colors they end up being assigned, you probably don‚Äôt need to worry too much about color correction; if you‚Äôre working with histology slides, you probably don‚Äôt need to mask the background; if you have a really even and diffuse lighting setup, you probably won‚Äôt have to deal with shadows or gradients.\nBackground masking with transparencies If you‚Äôre masking the background, use transparencies. This is pretty easy to do in GIMP, Photoshop, or ImageJ. The transparency layer (or alpha channel) is the fourth channel of an image (the other three being the R, G, and B channels), and recolorize treats it like a binary mask: any pixel with an alpha value of 1 is retained, and any pixel with an alpha value of \u0026lt; 1 is ignored. This means you don‚Äôt have to worry about finding a uniform background color that is sufficiently different from your foreground object in every image, which can otherwise be a real pain.\nUsing transparency is unambiguous, and has the bonus benefit of making for nicer plots, too, since you don‚Äôt have to worry about the corners of your images overlapping and blocking each other. All the images in this demo have transparent backgrounds. However, you can use the lower and upper arguments to set boundaries for excluding pixels as background based on their color (see documentation). Just know that these will be set to transparent internally.\nStep 1: Loading \u0026amp; processing images  How to get images into R.\n We can read in an image by passing the filepath to the readImage function. This is a pretty generic function (almost every image processing package in R has something similar); the recolorize version doesn\u0026rsquo;t even assign the output to a special class (so don\u0026rsquo;t try to print it).\n# define image path - we're using an image that comes with the package img_path \u0026lt;- system.file(\u0026quot;extdata/corbetti.png\u0026quot;, package = \u0026quot;recolorize\u0026quot;) # load image img \u0026lt;- readImage(img_path, resize = NULL, rotate = NULL) # it's just an array with 4 channels: dim(img) #\u0026gt; [1] 243 116 4  An image is a numeric array with either 3 or 4 channels (R, G, B, and optionally alpha for transparency). JPG images will only have 3 channels; PNG images will have 4. This is quite a small image (243x116 pixels) with 4 channels.\nWe can plot the whole array as an image, or plot one channel at a time. Notice that the red patches are bright in the R channel, same for blue-B channel, green-G channel, etc‚Äîand that the off-white patch is bright for all channels, while the black patches are dark in all channels. The alpha channel is essentially just a mask that tells us which parts of the image to ignore when processing it further.\nlayout(matrix(1:5, nrow = 1)) plotImageArray(img, main = \u0026quot;RGB image\u0026quot;) plotImageArray(img[ , , 1], main = \u0026quot;R channel\u0026quot;) plotImageArray(img[ , , 2], main = \u0026quot;G channel\u0026quot;) plotImageArray(img[ , , 3], main = \u0026quot;B channel\u0026quot;) plotImageArray(img[ , , 4], main = \u0026quot;Alpha channel\u0026quot;)  Optionally, when you load the image, you can resize it (highly recommended for large images) and rotate it. Image processing is computationally intensive, and R is not especially good at it, so downsampling it usually a good idea. A good rule of thumb for downsampling is that you want the smallest details you care about in the image (say, spots on a ladybug) to be about 5 pixels in diameter (so if your spots have a 20 pixel diameter, you can set resize = 0.25).\nThe only other thing you might do to your images before sending them to the main recolorize functions is blurImage. This is really useful for minimizing color variation due to texture (e.g. scales on a lizard, feathers on a bird, sensory hairs on an insect), and you can apply one of several smoothing algorithms from the imager package, including edge-preserving blurs:\nblurred_img \u0026lt;- blurImage(img, blur_function = \u0026quot;blur_anisotropic\u0026quot;, amplitude = 10, sharpness = 0.2)  This step is optional: most of the recolorize functions will accept a path to an image as well as an image array. But once you\u0026rsquo;re happy here, we can start defining color regions!\nStep 2: Initial clustering  Go from thousands of colors to a manageable number for further refinement.\n The color clustering in recolorize usually starts with an initial clustering step which produces more color clusters than the final color map will have, which are then edited and combined to form the final color map. We start with an over-clustering step because it is a quick way to go from an overwhelming number of colors (256^3 unique RGB colors) to a manageable number that can be manually inspected or automatically re-clustered. You‚Äôll usually do this using the recolorize function, which is the core of the package (go figure!):\ncorbetti \u0026lt;- system.file(\u0026quot;extdata/corbetti.png\u0026quot;, package = \u0026quot;recolorize\u0026quot;) recolorize_defaults \u0026lt;- recolorize(img = corbetti) #\u0026gt; #\u0026gt; Using 2^3 = 8 total bins  This function does a lot under the hood: we read in the image as an array, binned every pixel in the image into one of eight bins in RGB color space, calculated the average color of all the pixels assigned to a given bin, recolored the image to show which pixel was assigned to which color center, and returned all of that information in the recolorize_defaults object. Pretty much everything beyond this step will be a modification of one of those elements, so we\u0026rsquo;ll take a second to examine the contents of that output.\nThe recolorize class Objects of S3 class recolorize are lists with several elements:\nattributes(recolorize_defaults) #\u0026gt; $names #\u0026gt; [1] \u0026quot;original_img\u0026quot; \u0026quot;centers\u0026quot; \u0026quot;sizes\u0026quot; #\u0026gt; [4] \u0026quot;pixel_assignments\u0026quot; #\u0026gt; #\u0026gt; $class #\u0026gt; [1] \u0026quot;recolorize\u0026quot;    original_img is a a raster matrix, essentially a matrix of hex color codes. This is a more lightweight version of the 3D/4D color image array we loaded earlier, and can be plotted easily by running plot(recolorize_defaults$original_img).\n  centers is a matrix of RGB centers (0-1 range) for each of the color patches. Their order matches the index values in the pixel_assignments matrix.\n  sizes is a vector of patch sizes, whose order matches the row order of centers.\n  pixel_assignments is a paint-by-numbers matrix, where each pixel is coded as the color center to which it was assigned. For example, cells with a 1 have been assigned to the color represented by row 1 of centers. Background pixels are marked as 0.\n  If you plot the whole recolorize object, you\u0026rsquo;ll get back the plot you see above: the original image, the color map (where each pixel has been recolored), and the color palette. You can also plot each of these individually:\nlayout(matrix(1:3, nrow = 1), widths = c(0.45, 0.45, 0.1)) par(mar = rep(0, 4)) plot(recolorize_defaults$original_img) plotImageArray(recolorize_defaults$pixel_assignments / 8) plotColorPalette(recolorize_defaults$centers, recolorize_defaults$sizes, horiz = FALSE)  You\u0026rsquo;ll notice this doesn\u0026rsquo;t look exactly like the function output above. Aside from some wonky scaling issues, the pixel assignment matrix plotted as a grayscale image (and we had to divide it by the number of colors in the image so it was in a 0-1 range). That\u0026rsquo;s because we didn\u0026rsquo;t tell R which colors to make each of those values, so layer 1 is the darkest color and layer 8 is the brightest color in the image.\nYou can get the recolored image by calling recoloredImage:\n# type = raster gets you a raster (like original_img); type = array gets you an # image array recolored_img \u0026lt;- recoloredImage(recolorize_defaults, type = \u0026quot;array\u0026quot;) plotImageArray(recolored_img)  recoloredImage is just a shortcut function for constructImage, which lets you decide which colors to assign to each category in case you want to swap out the palette:\ncolors \u0026lt;- c(\u0026quot;navy\u0026quot;, \u0026quot;lightblue\u0026quot;, \u0026quot;blueviolet\u0026quot;, \u0026quot;turquoise\u0026quot;, \u0026quot;slateblue\u0026quot;, \u0026quot;royalblue\u0026quot;, \u0026quot;aquamarine\u0026quot;, \u0026quot;dodgerblue\u0026quot;) blue_beetle \u0026lt;- constructImage(recolorize_defaults$pixel_assignments, centers = t(col2rgb(colors) / 255)) # a very blue beetle indeed: plotImageArray(blue_beetle)  Now that you have a better understanding of what these objects contain and what to do with them, we can start to unpack exactly what this function is doing.\nThe recolorize function The main recolorize function has a simple goal: to take your image from a huge number of colors to a manageable number of color clusters. This falls under a category of methods for color quantization, although we have a slightly different goal here. The typical reason for doing color quantization is to simplify an image while making it look as visually similar as possible to the original; our goal is not to represent the original image, but to create a set of building blocks to combine and clean up so we can refer to whole color patches easily.\nIf you look at the documentation for the recolorize function, you‚Äôll see a lot of user-specifiable parameters. There are only really 3 major ones:\n the color space in which the clustering is done (color_space) the clustering method (the method argument) the number of color clusters (bins for method = hist and n for method = kmeans)  You can also map an image to an externally imposed set of colors using another function, imposeColors, which can be useful for batch processing images.\nWe\u0026rsquo;ll go over each of these parameters and what they do. I\u0026rsquo;ll give mild advice about how to navigate these options, but there\u0026rsquo;s a reason I\u0026rsquo;ve included all of theme here, which is that I think any combination of these parameters can be useful depending on the context.\nColor spaces Color spaces are ways to represent colors as points in multi-dimensional spaces, where each axis corresponds to some aspect of the color. You\u0026rsquo;re probably familiar with RGB (red-green-blue) color space and HSV (hue-saturation-value) color space. In RGB space, colors vary by the amount of red, green, and blue they have, where a coordinate of [0, 0, 1] would be pure blue (no red or green), [1, 1, 1] would be white, [0, 1, 1] would be cyan, etc. This is how most images are stored and displayed on computers, although it\u0026rsquo;s not always very intuitive.\nThe recolorize package gives you a variety of options for color spaces, but by far the two most commonly used are RGB (color_space = sRGB) and CIE Lab (color_space = Lab). CIE Lab is popular because it approximates perceptual uniformity, which means that the distances between colors in CIE Lab space are proportional to how different they actually seem to human beings. The axes represent luminance (L, 0 = black and 100 = white), red-green (a, negative values = more green and positive values = more red), and blue-yellow (b, negative values = more blue and positive values = more yellow). The idea is that something can be greenish-blue, or reddish-yellow, but not reddish-green, etc. This can be a little confusing, but the results it provides are really intuitive. For example, in RGB space, red is as similar to yellow as it is to black. In CIE Lab, red and yellow are close together, and are about equally far from black.\nI\u0026rsquo;ve written in more detail about color spaces for another package here, which I would recommend reading for a more detailed overview, but let\u0026rsquo;s see what happens if we plot all of the non-background pixels from our C. corbetti example in RGB compared to CIE Lab color space (forgive the crummy plotting):\nWe can identify green, red, blue, black, and white pixels in both sets of plots, but their distributions are very different.\nIn practice, I find myself toggling between these two color spaces depending on the color distributions in my images. For example, when dealing with C. corbetti, I would use RGB, because the beetle is literally red, green, and blue. When dealing with the red and green C. fulgidissima above, I found that CIE Lab produced better results, because it separates red and green pixels by much more distance. But in general, especially as you increase the number of initial clusters, this matters less at this stage than at the refinement stage (where you can switch between color spaces again). Because CIE Lab is not evenly distributed on all axes (i.e. is not a cube), you may need to use more bins in CIE Lab space than in RGB. (Try fitting the C. corbetti image with CIE Lab space and see what happens for an idea of how much the choice of color space can matter.)\nClustering methods The two clustering methods in recolorize are color histogram binning (fast, consistent, and deterministic) and k-means clustering (comparatively slower and heuristic, but more intuitive). The bins argument is accessed by the histogram method, and n goes with the kmeans method. I highly recommend the histogram binning unless you have a good reason not to use it, but there are good reasons to use k-means clustering sometimes.\nThe histogram binning method is essentially just a 3-dimensional color histogram: we divide up each channel of a color space into a predetermined number of bins, then count the number of pixels that fall into that bin and calculate their average color. So, when we divide each of 3 color channels into 2 bins, we end up with \\(2^3 = 8\\) total bins (which is why setting bins = 2 will produce 8 colors as above).\nk-means clustering, on the other hand, is a well-known method for partitioning data into n clusters. You just provide the number of clusters you want, and it will try to find the best locations for them, where ‚Äòbest‚Äô means minimizing the squared Euclidean distances between pixels and color centers within each cluster.\nTo appreciate these differences, we can fit the same number of colors (64) using the histogram method and the k-means method on the same image, then view the resulting color distributions:\n# fit 64 colors, both ways r_hist \u0026lt;- recolorize(img_path, method = \u0026quot;hist\u0026quot;, bins = 4, plotting = FALSE) #\u0026gt; #\u0026gt; Using 4^3 = 64 total bins r_k \u0026lt;- recolorize(img_path, method = \u0026quot;k\u0026quot;, n = 64, plotting = FALSE) plotColorClusters(r_hist$centers, r_hist$sizes, plus = .5, xlab = \u0026quot;red\u0026quot;, ylab = \u0026quot;green\u0026quot;, zlab = \u0026quot;blue\u0026quot;, mar = c(3, 3, 2, 2), main = \u0026quot;Histogram method\u0026quot;)  plotColorClusters(r_k$centers, r_k$sizes, plus = .5, xlab = \u0026quot;red\u0026quot;, ylab = \u0026quot;green\u0026quot;, zlab = \u0026quot;blue\u0026quot;, mar = c(3, 3, 2, 2), main = \u0026quot;k-means clustering\u0026quot;)  The histogram method produced a lot of tiny, nearly-empty clusters that are evenly distributed in the color space, with only a few large clusters (like the black and white ones). The k-means clustering method, on the other hand, produced a lot more medium-sized clusters, as well as splitting the black and white patches across multiple clusters.\nA lot of color segmentation tools will only use k-means clustering (or a similar method), because it‚Äôs relatively easy to implement and does produce good results if your images have clear color boundaries and very different colors (i.e. the pixels are far apart in color space). If you were going to stop at the initial clustering step, this would probably be a better option than the histogram binning for that reason. The main reason I recommend against it is that it is not deterministic: you will get different colors, and in a different order, every time you run it. For example, if we fit 10 colors three separate times, we get the following color palettes:\nk_list \u0026lt;- lapply(1:3, function(i) recolorize(img_path, \u0026quot;k\u0026quot;, n = 10, plotting = F)) layout(1:3) par(mar = rep(1, 4)) lapply(k_list, function(i) plotColorPalette(i$centers, i$sizes))  #\u0026gt; [[1]] #\u0026gt; NULL #\u0026gt; #\u0026gt; [[2]] #\u0026gt; NULL #\u0026gt; #\u0026gt; [[3]] #\u0026gt; NULL  The colors are similar, but not identical, and they are returned in an arbitrary order. If you run this code one day and pull out all the red clusters by their index, or merge the multiple green clusters, those values will change the next time you run the code. That and the need to specify cluster numbers for each image are more or less why I recommend not using this method unless you have a reason.\nBinning the colors (histograms) is usually more viable as a first step. It‚Äôs quite fast, since we‚Äôre not really doing any clustering; the bins we assign the pixels to will be the same for every image, and we‚Äôre not calculating the distances between the pixels and their assigned color. It‚Äôs also deterministic, which means you get the same result every single time you run it. The downside is that makes this approach almost guaranteed to over-split colors, since your color regions will rarely fall cleanly within the boundaries of these bins, and many of the bins you end up with will be empty or have very few pixels.\nNumber of clusters Unlike the color space and binning method, this parameter is pretty intuitive: the more clusters you fit, the more the colors in your image will be split up. It‚Äôs convenient to use the same scheme for every image in your dataset, so you might end up using whatever values are needed for your most complex image and over-splitting most of your other images. That‚Äôs usually fine, because the next set of steps will try to lump colors together or remove minor details. You want to be just granular enough to capture the details you care about, and it‚Äôs okay if some colors are split up.\nOne thing to note is that the bins argument allows for a different number of bins for each channel. Setting bins = 2 will divide each channel into 2 bins, but you can also set bins = c(5, 2, 2) to divide up the red channel into 5 bins and the blue and green channels into 2 bins (if in RGB space). This can be convenient if you have a lot of color diversity on only one axis, e.g. you have photographs of mammals which are shades of reddish-brown, and don\u0026rsquo;t need to waste computational time dividing up the blue channel.\n# we can go from an unacceptable to an acceptable color map in # CIE Lab space by adding a single additional bin in the luminance channel: r_hist_2 \u0026lt;- recolorize(img_path, method = \u0026quot;hist\u0026quot;, color_space = \u0026quot;Lab\u0026quot;, bins = 2) #\u0026gt; #\u0026gt; Using 2^3 = 8 total bins  r_hist_322 \u0026lt;- recolorize(img_path, method = \u0026quot;hist\u0026quot;, bins = c(3, 2, 2)) #\u0026gt; #\u0026gt; Using 3*2*2 = 12 bins  imposeColors() Another option is to impose colors on an image, rather than using intrinsic image colors. Every pixel is assigned to the color it is closest to in some specified color space. Usually, this is useful for batch processing: you get colors from one image, then map them onto another image, so that the color centers correspond across all your images.\nim1 \u0026lt;- system.file(\u0026quot;extdata/ocellata.png\u0026quot;, package = \u0026quot;recolorize\u0026quot;) im2 \u0026lt;- system.file(\u0026quot;extdata/ephippigera.png\u0026quot;, package = \u0026quot;recolorize\u0026quot;) # fit the first image fit1 \u0026lt;- recolorize(im1) #\u0026gt; #\u0026gt; Using 2^3 = 8 total bins  # fit the second image using colors from the first # adjust_centers = TRUE would find the average color of all the pixels assigned to # the imposed colors to better match the raw image fit2 \u0026lt;- imposeColors(im2, fit1$centers, adjust_centers = FALSE)  Step 3: Refinement  Using simple rules to improve the initial results.\n Once we‚Äôve reduced an image down to a tractable number of colors, we can define simple procedures for how to combine them based on similarity. recolorize (currently) comes with two of these: recluster, which merges colors by perceived similarity, and thresholdRecolor, which drops minor colors. Both are simple, but surprisingly effective. They‚Äôre also built on top of some really simple functions we‚Äôll see in a bit, so if you need to, you can build out a similar procedure tailored to your dataset‚Äîfor example, combining layers based only on their brightness values, or only combining green layers.\nrecluster() and recolorize2() This is the one I use the most often, and its implementation is really simple. This function calculates the Euclidean distances between all the color centers in a recolorize object, clusters them hierarchically using hclust, then uses a user-specified cutoff to combine the most similar colors. As with recolorize, you can choose your color space, and that will make a big difference. Let‚Äôs see this in action:\nrecluster_results \u0026lt;- recluster(recolorize_defaults, similarity_cutoff = 45)  Notice the color dendrogram: it lumped together clusters 4 \u0026amp; 7, clusters 3 \u0026amp; 5, and clusters 6 \u0026amp; 8, because their distance was less than 45. This is in CIE Lab space; if we use RGB space, the range of distances is 0-1:\nrecluster_rgb \u0026lt;- recluster(recolorize_defaults, color_space = \u0026quot;sRGB\u0026quot;, similarity_cutoff = 0.5)  In this case, we get the same results, but this is always worth playing around with. Despite its simplicity, this function is highly effective at producing intuitive results. This is partly because, in only using color similarity to combine clusters, it does not penalize smaller color clusters that can still retain important details. I find myself using it so often that I included a wrapper function, recolorize2, to run recolorize and recluster sequentially in a single step:\n# let's use a different image: img \u0026lt;- system.file(\u0026quot;extdata/chongi.png\u0026quot;, package = \u0026quot;recolorize\u0026quot;) # this is identical to running: # fit1 \u0026lt;- recolorize(img, bins = 3) # fit2 \u0026lt;- recluster(fit1, similarity_cutoff = 50) chongi_fit \u0026lt;- recolorize2(img, bins = 3, cutoff = 45) #\u0026gt; #\u0026gt; Using 3^3 = 27 total bins  There‚Äôs also a lot of room for modification here: this is a pretty unsophisticated rule for combining color clusters (ignoring, for example, cluster size, proximity, geometry, and boundary strength), but it‚Äôs pretty simple to write better rules if you can think of them, because the functions that are called to implement this are also exported by the package.\nthresholdRecolor() An even simpler rule: drop the smallest color clusters whose cumulative sum (as a proportion of total pixels assigned) is lower than some threshold, like 5% of the image. I thought this would be too simple to be useful, but every once in a while it‚Äôs just the thing, especially if you always end up with weird spurious details.\nchongi_threshold \u0026lt;- thresholdRecolor(chongi_fit, pct = 0.1)  Step 4: Minor edits  Cleaning up the details.\n These are functions that can be called individually to address problem areas in specific images, or strung together as building blocks to do more complicated operations.\nabsorbLayer \u0026ldquo;Absorbs\u0026rdquo; all or part of a layer into the surrounding colors, optionally according to a size or location condition.\nimg \u0026lt;- system.file(\u0026quot;extdata/fulgidissima.png\u0026quot;, package = \u0026quot;recolorize\u0026quot;) ful_init \u0026lt;- recolorize2(img, bins = 3, cutoff = 60, plotting = F) #\u0026gt; #\u0026gt; Using 3^3 = 27 total bins ful_absorb \u0026lt;- absorbLayer(ful_init, layer_idx = 3, function(s) s \u0026lt;= 250, y_range = c(0, 0.8), highlight_color = \u0026quot;cyan\u0026quot;)  This function is really useful, but fair warning: it can be quite slow. It works by finding the color patch with which each highlighted component shares the longest border and switching the highlighted component to that color, which is more sophisticated than simply switching the patch color, but requires many more calculations. If you find yourself using this a lot, it\u0026rsquo;s a good idea to make sure you\u0026rsquo;ve downsampled your images using the resize argument.\neditLayer/editLayers Applies one of several morphological operations from imager to a layer (or layers) of a recolorize object. This can be used to despeckle, fill in holes, or uniformly grow or shrink a color patch. In practice, this is mostly only useful for fixing small imperfections; anything too drastic tends to alter the overall shape of the patch.\n# cleans up some of the speckles in the above output ful_clean \u0026lt;- editLayers(ful_absorb, layer_idx = c(2, 5), operations = \u0026quot;fill\u0026quot;, px_sizes = 3, plotting = T)  This function is also easy to modify. Internally, it splits the color map into individual masks using splitByColor() (another recolorize function), then converts those to pixsets for use in imager before slotting them back in with the unchanged layers.\nmergeLayers Sometimes, you don‚Äôt want to define fancy rules for deciding which layers to combine; you just want to combine layers. That‚Äôs what this function is for. It takes in a list of numeric vectors for layers to combine (layers in the same vector are combined; those in different list elements are kept separate).\nmerge_fit \u0026lt;- mergeLayers(recolorize_defaults, merge_list = list(1, 2, c(3, 5), c(4, 7), c(6, 8)))  You might notice this is a bit different than our recluster results above. That‚Äôs because internally, recluster actually uses imposeColors to refit the color map, rather than just merging layers; I have found this often produces slightly nicer results, because pixels that were on the border of one cutoff or another don‚Äôt get stranded in the wrong layer. On the other hand, mergeLayers is considerably faster.\nStep 4.5: Visualizations Making color maps is an obviously visual process, so it‚Äôs good to use visual feedback as much as possible. We‚Äôve already seen a few of these functions in action, specifically plotColorPalette and plotImageArray, which are used in almost every function that produces a recolorize object. I‚Äôll point out three others that I think are quite useful: imDist, plotColorClusters, and splitByColor (which also doubles as an export function).\nimDist Compares two versions of the same image by calculating the color distance between the colors of each pair of pixels (imDist), and gives you a few more options for plotting the results (imHeatmap). You can use it to get the distances between the original image and the color map:\nlayout(matrix(1:2, nrow = 1)) # calculates the distance matrix and plots the results dist_original \u0026lt;- imDist(readImage(img), recoloredImage(ful_clean), color_space = \u0026quot;sRGB\u0026quot;) # more plotting options - setting the range is important for comparing # across images (max is sqrt(3) in sRGB space, ~120 in Lab) imHeatmap(dist_original, viridisLite::inferno(100), range = c(0, sqrt(3)))  The resulting object is a simple matrix of distances between each pair of pixels in the given color space. These are essentially residuals:\nhist(dist_original, main = \u0026quot;sRGB distances\u0026quot;, xlab = \u0026quot;Distance\u0026quot;)  A word of warning here: it is easy to look at this and decide to come up with a procedure for automatically fitting color maps using a kind of AIC metric, trying to get the lowest SSE with the minimum set of color centers. You‚Äôre welcome to try that, but given that this is discarding spatial information, it is probably not a general solution (I haven‚Äôt had much luck with it). But there is probably some room to play here.\nsplitByColor This is a dual-use function: by splitting up the color map into individual layers, you not only can examine the individual layers and decide whether they need any editing or merging, but you also get out a binary mask representing each layer, so you can export individual patches.\nlayout(matrix(1:10, nrow = 2, byrow = TRUE)) # 'overlay' is not always the clearest option, but it is usually the prettiest: layers \u0026lt;- splitByColor(recluster_results, plot_method = \u0026quot;overlay\u0026quot;) # layers is a list of matrices, which we can just plot: lapply(layers, plotImageArray)  #\u0026gt; [[1]] #\u0026gt; [[1]]$mar #\u0026gt; [1] 0 0 2 0 #\u0026gt; #\u0026gt; #\u0026gt; [[2]] #\u0026gt; [[2]]$mar #\u0026gt; [1] 0 0 2 0 #\u0026gt; #\u0026gt; #\u0026gt; [[3]] #\u0026gt; [[3]]$mar #\u0026gt; [1] 0 0 2 0 #\u0026gt; #\u0026gt; #\u0026gt; [[4]] #\u0026gt; [[4]]$mar #\u0026gt; [1] 0 0 2 0 #\u0026gt; #\u0026gt; #\u0026gt; [[5]] #\u0026gt; [[5]]$mar #\u0026gt; [1] 0 0 2 0  Step 5: Exporting  The whole point of this package is to make it easier to use other methods!\n Exporting to aimges The most direct thing you can do is simply export your recolored images as images, then pass those to whatever other tool you‚Äôd like to use, although obviously this doesn‚Äôt take full advantage of the format:\n# export color map png::writePNG(recoloredImage(recluster_results), target = \u0026quot;recolored_corbetti.png\u0026quot;) # export individual layers from splitByColor for (i in 1:length(layers)) { png::writePNG(layers[[i]], target = paste0(\u0026quot;layer_\u0026quot;, i, \u0026quot;.png\u0026quot;)) }  pavo package You can also convert a recolorize object to a classify object in the wonderful pavo package and then run an adjacency analysis. Bonus points if you have reflectance spectra for each of your color patches: by combining the spatial information in the color map with the coldist object generated by spectral measurements, you can run adjacency analysis for the visual system(s) of your choice right out of the box!\n# convert to a classify object as_classify \u0026lt;- classify_recolorize(recluster_results, imgname = \u0026quot;corbetti\u0026quot;) adj_analysis \u0026lt;- pavo::adjacent(as_classify, xscale = 10) # run adjacent directly using human perceptual color distances (i.e. no spectral data - proceed with caution) adj_human \u0026lt;- recolorize_adjacency(recluster_results)  You can also run an adjacency analysis with recolorize_adjacency, but only as long as you keep your skeptic hat on. This function works by calculating a coldist object right from the CIE Lab colors in the color maps, which are themselves probably derived from your RGB image, which is at best a very loose representation of how these colors appear to human eyes. The only reason this is at all reasonable is that it‚Äôs producing these values for human vision, so you will be able to see if it‚Äôs completely unreasonable. This is fine for getting some preliminary results or if you‚Äôre working with aggregate data from many sources and you‚Äôre content with specifically human (not just non-UV, but only human) vision. Otherwise, it‚Äôs probably a last resort.\npatternize Coming soon (pending a patternize update), and with many thanks to Steven van Belleghem for his help in making recolorize and patternize get along!\nSome advice This is a lot of options. How do I choose a procedure? Most things will more or less work; if it looks reasonable, it is. Keep in mind that there is a big difference between getting slightly different color maps and getting qualitatively different results. Keep your final goal in mind. You can also try lots of different things and see if it makes a real difference.\nI wish I could write a single function that would do all of these steps in the correct sequence and produce perfect results; the reason that function does not exist is because I find I have to do experiment a fair amount with every image set, and I often end up with a different order of operations depending on the problem.\nStart with recolorize2 and identify the common problems you\u0026rsquo;re encountering. Does it make sense to batch process all of your images, then refine them individually? Is it better to choose a different cutoff for each image? Luckily, these functions are relatively fast, so you can test out different options.\nYou can also get way fancier with cutoffs than I have here. This package is built on some pretty simple scaffolding: you get a starting set of clusters, then you modify them. If you have a better/more refined way of deciding which colors to cluster, then go for it. I will soon be adding some example workflows from collaborators which should be helpful.\nThere is another very tempting option: make a small training set of nice color maps manually with recolorize, then use those to either fit a statistical model for other fits or use machine learning to do the rest. I think this is a really compelling idea; I just haven\u0026rsquo;t tested it yet. Maybe you want to try it out?\nCan you define an optimality condition to do all the segmentation automatically? As far as I can tell, no. This is because of the problem I pointed out at the beginning: the \u0026lsquo;correct\u0026rsquo; segmentation depends on your particular question more than anything else.\nHow should you store the code used to generate a color map? I like to use rlang::enexpr to capture the code I run to generate a color map, and store it as another aspect of the recolorize object, like so:\nlibrary(rlang) # run this code, then capture it in the brackets: steps \u0026lt;- { fit \u0026lt;- recolorize2(img,bins = 3, cutoff = 50) fit2 \u0026lt;- editLayers(fit, c(2, 5), operations = \u0026quot;fill\u0026quot;, px_sizes = 3) } %\u0026gt;% enexprs() fit2$steps \u0026lt;- steps  What about batch processing? Every function in this package operates on a single image at a time. This is because I\u0026rsquo;ve found that there is so much variation in how people go about batch processing anything: if I tried to impose what I considered to be a useful batch processing structure, within a few months I would find that it was too inflexible for some new project structure I needed to use it for. So, instead, the idea is that you can write your own batch processing functions or for loops as needed to suit your data structure. Or maybe you come up with something better than I can think of, in which case, please let me add it to the package!\nWhat about machine learning approaches? Using machine learning could work, but only if you already have segmented images for use in training (which presumably you had to do by hand), and making that training set could be extremely time consuming; and the amount of modification required to get a generic algorithm to work might be unjustifiable given the size of (or variance in) your image set. This problem gets a lot worse the more images we have and the more different they are, especially if you have a lot of variance in a small dataset (pretty typical in comparative biology).\nThat said, I don\u0026rsquo;t have much background in ML of any stripe. If you have a handy idea in this area, I would love to know about it.\nJust for fun There are two fun functions in here: wernerColor and recolorizeVector.\nwernerColor remaps a recolorize object to the colors in Werner\u0026rsquo;s Nomenclature of Colors by Patrick Syme (1821), one of the first attempts at an objective color reference in western science, notably used by Charles Darwin. This is always fun to try out, especially given how many things get tagged as \u0026ldquo;veinous blood red\u0026rdquo; (delightful!):\nrc_werner \u0026lt;- wernerColor(recluster_results)  Finally, recolorizeVector converts a bitmap (i.e. pixel) image to a vector image.\nrc_vector \u0026lt;- recolorizeVector(recluster_fit, size_filter = 0.15, smoothness = 5, plotting = TRUE) # to save as an SVG: svg(filename = \u0026quot;corbett_vector.svg\u0026quot;, width = 2, height = 4) plot(rc_vector) dev.off()  This function is VERY experimental. If it gives you errors or looks too funky, try decreasing the size filter (which absorbs all components below some size to simplify the image) and the smoothness. Then again, sometimes you want things to look funky. If this is the case, recolorizeVector will happily enable you.\n","date":1618272000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1618349069,"objectID":"e99cbd225ad595d6a216ac0cb259f778","permalink":"/post/introduction-to-recolorize/","publishdate":"2021-04-13T00:00:00Z","relpermalink":"/post/introduction-to-recolorize/","section":"post","summary":"color-based image segmentation (for people with other things to do)  You can also tour the functions in the function gallery.\n The recolorize package is a toolbox for making color maps, essentially color-based image segmentation, using a combination of automatic, semi-automatic, and manual procedures.","tags":["recolorize","color","r packages"],"title":"Introduction to recolorize","type":"post"},{"authors":["Hannah Weller"],"categories":[],"content":"            The plotPixels function in colordistance is pretty inflexible. It was originally meant as a diagnostic tool, and the plots it produces are not exactly beautiful:\nlibrary(colordistance) # image from the 'recolorize' package (github.com/hiweller/recolorize) img \u0026lt;- system.file(\u0026quot;extdata/fulgidissima.png\u0026quot;, package = \u0026quot;recolorize\u0026quot;) # load the image: loaded_img \u0026lt;- loadImage(img) # set the plot layout for opposing pixel plots layout(matrix(1:3, nrow = 1), widths = c(0.46, 0.08, 0.46)) # plot the pixels in RGB color space from two angles: plotPixels(loaded_img) # plot the original image par(mar = rep(0, 4)) # no margin plotImage(loaded_img) # and pixels from the opposite angle: plotPixels(loaded_img, angle = -45)  These plots are certainly fine if you want to scope out the color distribution in the image, but I wouldn‚Äôt want to display them for communication: the axis text is too large and some of the tick marks overlap; the axis labels are oddly spaced; and depending on the intention of the graphic, I might not want the grid or the plot frame. The axis label thing in particular has always bothered me.\nSome of those changes are possible to make by passing additional parameters to the plotPixels function itself, but in practice, I often want more flexibility than this provides. Luckily, the function itself has such simple building blocks that it‚Äôs pretty easy to unpack them to get more customized plots.\nThis is how plotPixels works:\n It takes a dataframe of RGB colors, where pixels are rows and color channels are columns. It creates a vector of hex codes from the RGB colors to tell R which color to make each point. It uses scatterplot3d to plot in the 3D color space indicated with the color.space argument.  I chose the scatterplot3d package because, of all the 3D plotting packages, it‚Äôs the most lightweight, and more or less just extends the base plotting syntax. It was also written in 2003, so there are a lot of newer packages that provide prettier output and more options, like plot3D by Karline Soetaert, or the plotly library.\n# load the plot3D library library(plot3D) # get the RGB pixel matrix pixels \u0026lt;- loaded_img$filtered.rgb.2d # make the hex color vector using the rgb() function color_vector \u0026lt;- rgb(pixels); head(color_vector) # just a bunch of hex codes!  ## [1] \u0026quot;#247872\u0026quot; \u0026quot;#006862\u0026quot; \u0026quot;#006B62\u0026quot; \u0026quot;#00776A\u0026quot; \u0026quot;#00645C\u0026quot; \u0026quot;#007B71\u0026quot;  # use the scatter3D function scatter3D(x = pixels[ , 1], y = pixels[ , 2], z = pixels[ , 3], colvar = 1:nrow(pixels), # \u0026lt;- note we have to make a fake 'variable' to assign each pixel a different color col = color_vector, colkey = FALSE, # gets rid of the (in this case meaningless) legend xlab = \u0026quot;Red\u0026quot;, ylab = \u0026quot;Green\u0026quot;, zlab = \u0026quot;Blue\u0026quot;)  Even the default scatter3D plot looks a lot better to me: the axis labels hug the axes, and the angle is nicer. We can get fancier with a lot of the options, too:\nscatter3D(x = pixels[ , 1], y = pixels[ , 2], z = pixels[ , 3], colvar = 1:nrow(pixels), col = color_vector, colkey = F, xlab = \u0026quot;Red\u0026quot;, ylab = \u0026quot;Green\u0026quot;, zlab = \u0026quot;Blue\u0026quot;, xlim = 0:1, ylim = 0:1, zlim = 0:1, # RGB max and min pch = 19, # filled circles alpha = 0.5, # partially transparent theta = 115, phi = 25, # change viewing angle bty = \u0026quot;bl2\u0026quot;) # black grid background looks sort of cool  What if you want to plot in another color space besides RGB? The only difference is that you have to first convert your pixel matrix to a given color space, for which you have several options.\n# convert pixels to CIE Lab coordinates pixels_lab \u0026lt;- convertColor(pixels, from = \u0026quot;sRGB\u0026quot;, to = \u0026quot;Lab\u0026quot;) # color vector remains the same! color_vector \u0026lt;- rgb(pixels) scatter3D(x = pixels_lab[ , 1], y = pixels_lab[ , 2], z = pixels_lab[ , 3], colvar = 1:nrow(pixels_lab), col = color_vector, colkey = F, xlab = \u0026quot;Luminance\u0026quot;, ylab = \u0026quot;a (red-green)\u0026quot;, zlab = \u0026quot;b (yellow-blue)\u0026quot;, theta = 120, phi = -5, xlim = c(0, 100), pch = 19, # filled circles alpha = 0.5, # partially transparent bty = \u0026quot;b2\u0026quot;)  As an aside, it‚Äôs good practice to set the axis limits thoughtfully. This is easy with RGB: all three channels have a 0-1 range. With CIE Lab, this depends on your reference white. The L channel will always be 0-100, and the outer limits for the a and b channels are -127 to 128 each, but for a given reference white converting from sRGB it will be a subset within that range. The axis limits will be set to the range of the data by default, which could be misleading if you‚Äôre comparing plots of multiple images.\nIf you‚Äôd rather have an interactive plot (especially helpful for data exploration), you can use the plotly package. I find I have to implement more workarounds to get these plots to behave how I‚Äôd expect, but once you get out an interactive plot, it‚Äôs pretty slick:\nlibrary(plotly, quietly = TRUE) # let's subsample down to 100 pixels just for this example pixel_sub \u0026lt;- as.data.frame(pixels[sample(1:nrow(pixels), 100), ]) plotly_colors \u0026lt;- rgb(pixel_sub) # and plot! plot_ly(data = pixel_sub, x = ~r, y = ~g, z = ~b, type = \u0026quot;scatter3d\u0026quot;, mode = \u0026quot;markers\u0026quot;, color = I(plotly_colors), # this is a bit of a hack and you'll get a warning... colors = plotly_colors)   {\"x\":{\"visdat\":{\"948a74a44f66\":[\"function () \",\"plotlyVisDat\"]},\"cur_data\":\"948a74a44f66\",\"attrs\":{\"948a74a44f66\":{\"x\":{},\"y\":{},\"z\":{},\"mode\":\"markers\",\"color\":[\"#4D272F\",\"#008173\",\"#220C10\",\"#DB4042\",\"#402E2E\",\"#6A2023\",\"#342232\",\"#578900\",\"#31811C\",\"#6B813F\",\"#0092BA\",\"#4B3842\",\"#9F343D\",\"#00AD7B\",\"#52AA23\",\"#51333D\",\"#0B803A\",\"#405D44\",\"#549BC2\",\"#709200\",\"#559864\",\"#67202C\",\"#6E7600\",\"#007E3A\",\"#38A337\",\"#676A20\",\"#55423B\",\"#85C400\",\"#425F46\",\"#009D42\",\"#37833C\",\"#31AC00\",\"#539000\",\"#C43628\",\"#858F00\",\"#9B1F2C\",\"#009C3D\",\"#B9202A\",\"#50512C\",\"#8A8884\",\"#822122\",\"#329D86\",\"#6F661D\",\"#008D3B\",\"#006E45\",\"#006E7A\",\"#861A31\",\"#339000\",\"#427A0F\",\"#BBC4E1\",\"#29A234\",\"#52781E\",\"#049509\",\"#877D00\",\"#78131D\",\"#509B35\",\"#0084D4\",\"#00B27B\",\"#00697F\",\"#7D272B\",\"#44A212\",\"#BA9E00\",\"#6E303B\",\"#325E3D\",\"#288929\",\"#781E21\",\"#638B00\",\"#1A1B20\",\"#E47C00\",\"#832330\",\"#837F41\",\"#546E0D\",\"#611F22\",\"#30822C\",\"#66272E\",\"#7A770C\",\"#6E7600\",\"#3B6E3D\",\"#972931\",\"#009658\",\"#573B39\",\"#1D963C\",\"#00DCBE\",\"#4A5786\",\"#8B8E00\",\"#006A85\",\"#00852E\",\"#4E803E\",\"#006C82\",\"#00972E\",\"#009037\",\"#4C711E\",\"#531C29\",\"#0072A8\",\"#3B262B\",\"#4C9628\",\"#698A35\",\"#658300\",\"#B96612\",\"#9F5918\"],\"colors\":[\"#4D272F\",\"#008173\",\"#220C10\",\"#DB4042\",\"#402E2E\",\"#6A2023\",\"#342232\",\"#578900\",\"#31811C\",\"#6B813F\",\"#0092BA\",\"#4B3842\",\"#9F343D\",\"#00AD7B\",\"#52AA23\",\"#51333D\",\"#0B803A\",\"#405D44\",\"#549BC2\",\"#709200\",\"#559864\",\"#67202C\",\"#6E7600\",\"#007E3A\",\"#38A337\",\"#676A20\",\"#55423B\",\"#85C400\",\"#425F46\",\"#009D42\",\"#37833C\",\"#31AC00\",\"#539000\",\"#C43628\",\"#858F00\",\"#9B1F2C\",\"#009C3D\",\"#B9202A\",\"#50512C\",\"#8A8884\",\"#822122\",\"#329D86\",\"#6F661D\",\"#008D3B\",\"#006E45\",\"#006E7A\",\"#861A31\",\"#339000\",\"#427A0F\",\"#BBC4E1\",\"#29A234\",\"#52781E\",\"#049509\",\"#877D00\",\"#78131D\",\"#509B35\",\"#0084D4\",\"#00B27B\",\"#00697F\",\"#7D272B\",\"#44A212\",\"#BA9E00\",\"#6E303B\",\"#325E3D\",\"#288929\",\"#781E21\",\"#638B00\",\"#1A1B20\",\"#E47C00\",\"#832330\",\"#837F41\",\"#546E0D\",\"#611F22\",\"#30822C\",\"#66272E\",\"#7A770C\",\"#6E7600\",\"#3B6E3D\",\"#972931\",\"#009658\",\"#573B39\",\"#1D963C\",\"#00DCBE\",\"#4A5786\",\"#8B8E00\",\"#006A85\",\"#00852E\",\"#4E803E\",\"#006C82\",\"#00972E\",\"#009037\",\"#4C711E\",\"#531C29\",\"#0072A8\",\"#3B262B\",\"#4C9628\",\"#698A35\",\"#658300\",\"#B96612\",\"#9F5918\"],\"alpha_stroke\":1,\"sizes\":[10,100],\"spans\":[1,20],\"type\":\"scatter3d\"}},\"layout\":{\"margin\":{\"b\":40,\"l\":60,\"t\":25,\"r\":10},\"scene\":{\"xaxis\":{\"title\":\"r\"},\"yaxis\":{\"title\":\"g\"},\"zaxis\":{\"title\":\"b\"}},\"hovermode\":\"closest\",\"showlegend\":false},\"source\":\"A\",\"config\":{\"showSendToCloud\":false},\"data\":[{\"x\":[0.301960784313725,0,0.133333333333333,0.858823529411765,0.250980392156863,0.415686274509804,0.203921568627451,0.341176470588235,0.192156862745098,0.419607843137255,0,0.294117647058824,0.623529411764706,0,0.32156862745098,0.317647058823529,0.0431372549019608,0.250980392156863,0.329411764705882,0.43921568627451,0.333333333333333,0.403921568627451,0.431372549019608,0,0.219607843137255,0.403921568627451,0.333333333333333,0.52156862745098,0.258823529411765,0,0.215686274509804,0.192156862745098,0.325490196078431,0.768627450980392,0.52156862745098,0.607843137254902,0,0.725490196078431,0.313725490196078,0.541176470588235,0.509803921568627,0.196078431372549,0.435294117647059,0,0,0,0.525490196078431,0.2,0.258823529411765,0.733333333333333,0.16078431372549,0.32156862745098,0.0156862745098039,0.529411764705882,0.470588235294118,0.313725490196078,0,0,0,0.490196078431373,0.266666666666667,0.729411764705882,0.431372549019608,0.196078431372549,0.156862745098039,0.470588235294118,0.388235294117647,0.101960784313725,0.894117647058824,0.513725490196078,0.513725490196078,0.329411764705882,0.380392156862745,0.188235294117647,0.4,0.47843137254902,0.431372549019608,0.231372549019608,0.592156862745098,0,0.341176470588235,0.113725490196078,0,0.290196078431373,0.545098039215686,0,0,0.305882352941176,0,0,0,0.298039215686275,0.325490196078431,0,0.231372549019608,0.298039215686275,0.411764705882353,0.396078431372549,0.725490196078431,0.623529411764706],\"y\":[0.152941176470588,0.505882352941176,0.0470588235294118,0.250980392156863,0.180392156862745,0.125490196078431,0.133333333333333,0.537254901960784,0.505882352941176,0.505882352941176,0.572549019607843,0.219607843137255,0.203921568627451,0.67843137254902,0.666666666666667,0.2,0.501960784313725,0.364705882352941,0.607843137254902,0.572549019607843,0.596078431372549,0.125490196078431,0.462745098039216,0.494117647058824,0.63921568627451,0.415686274509804,0.258823529411765,0.768627450980392,0.372549019607843,0.615686274509804,0.513725490196078,0.674509803921569,0.564705882352941,0.211764705882353,0.56078431372549,0.12156862745098,0.611764705882353,0.125490196078431,0.317647058823529,0.533333333333333,0.129411764705882,0.615686274509804,0.4,0.552941176470588,0.431372549019608,0.431372549019608,0.101960784313725,0.564705882352941,0.47843137254902,0.768627450980392,0.635294117647059,0.470588235294118,0.584313725490196,0.490196078431373,0.0745098039215686,0.607843137254902,0.517647058823529,0.698039215686274,0.411764705882353,0.152941176470588,0.635294117647059,0.619607843137255,0.188235294117647,0.368627450980392,0.537254901960784,0.117647058823529,0.545098039215686,0.105882352941176,0.486274509803922,0.137254901960784,0.498039215686275,0.431372549019608,0.12156862745098,0.509803921568627,0.152941176470588,0.466666666666667,0.462745098039216,0.431372549019608,0.16078431372549,0.588235294117647,0.231372549019608,0.588235294117647,0.862745098039216,0.341176470588235,0.556862745098039,0.415686274509804,0.52156862745098,0.501960784313725,0.423529411764706,0.592156862745098,0.564705882352941,0.443137254901961,0.109803921568627,0.447058823529412,0.149019607843137,0.588235294117647,0.541176470588235,0.513725490196078,0.4,0.349019607843137],\"z\":[0.184313725490196,0.450980392156863,0.0627450980392157,0.258823529411765,0.180392156862745,0.137254901960784,0.196078431372549,0,0.109803921568627,0.247058823529412,0.729411764705882,0.258823529411765,0.23921568627451,0.482352941176471,0.137254901960784,0.23921568627451,0.227450980392157,0.266666666666667,0.76078431372549,0,0.392156862745098,0.172549019607843,0,0.227450980392157,0.215686274509804,0.125490196078431,0.231372549019608,0,0.274509803921569,0.258823529411765,0.235294117647059,0,0,0.156862745098039,0,0.172549019607843,0.23921568627451,0.164705882352941,0.172549019607843,0.517647058823529,0.133333333333333,0.525490196078431,0.113725490196078,0.231372549019608,0.270588235294118,0.47843137254902,0.192156862745098,0,0.0588235294117647,0.882352941176471,0.203921568627451,0.117647058823529,0.0352941176470588,0,0.113725490196078,0.207843137254902,0.831372549019608,0.482352941176471,0.498039215686275,0.168627450980392,0.0705882352941176,0,0.231372549019608,0.23921568627451,0.16078431372549,0.129411764705882,0,0.125490196078431,0,0.188235294117647,0.254901960784314,0.0509803921568627,0.133333333333333,0.172549019607843,0.180392156862745,0.0470588235294118,0,0.23921568627451,0.192156862745098,0.345098039215686,0.223529411764706,0.235294117647059,0.745098039215686,0.525490196078431,0,0.52156862745098,0.180392156862745,0.243137254901961,0.509803921568627,0.180392156862745,0.215686274509804,0.117647058823529,0.16078431372549,0.658823529411765,0.168627450980392,0.156862745098039,0.207843137254902,0,0.0705882352941176,0.0941176470588235],\"mode\":\"markers\",\"type\":\"scatter3d\",\"marker\":{\"color\":[\"rgba(77,39,47,1)\",\"rgba(0,129,115,1)\",\"rgba(34,12,16,1)\",\"rgba(219,64,66,1)\",\"rgba(64,46,46,1)\",\"rgba(106,32,35,1)\",\"rgba(52,34,50,1)\",\"rgba(87,137,0,1)\",\"rgba(49,129,28,1)\",\"rgba(107,129,63,1)\",\"rgba(0,146,186,1)\",\"rgba(75,56,66,1)\",\"rgba(159,52,61,1)\",\"rgba(0,173,123,1)\",\"rgba(82,170,35,1)\",\"rgba(81,51,61,1)\",\"rgba(11,128,58,1)\",\"rgba(64,93,68,1)\",\"rgba(84,155,194,1)\",\"rgba(112,146,0,1)\",\"rgba(85,152,100,1)\",\"rgba(103,32,44,1)\",\"rgba(110,118,0,1)\",\"rgba(0,126,58,1)\",\"rgba(56,163,55,1)\",\"rgba(103,106,32,1)\",\"rgba(85,66,59,1)\",\"rgba(133,196,0,1)\",\"rgba(66,95,70,1)\",\"rgba(0,157,66,1)\",\"rgba(55,131,60,1)\",\"rgba(49,172,0,1)\",\"rgba(83,144,0,1)\",\"rgba(196,54,40,1)\",\"rgba(133,143,0,1)\",\"rgba(155,31,44,1)\",\"rgba(0,156,61,1)\",\"rgba(185,32,42,1)\",\"rgba(80,81,44,1)\",\"rgba(138,136,132,1)\",\"rgba(130,33,34,1)\",\"rgba(50,157,134,1)\",\"rgba(111,102,29,1)\",\"rgba(0,141,59,1)\",\"rgba(0,110,69,1)\",\"rgba(0,110,122,1)\",\"rgba(134,26,49,1)\",\"rgba(51,144,0,1)\",\"rgba(66,122,15,1)\",\"rgba(187,196,225,1)\",\"rgba(41,162,52,1)\",\"rgba(82,120,30,1)\",\"rgba(4,149,9,1)\",\"rgba(135,125,0,1)\",\"rgba(120,19,29,1)\",\"rgba(80,155,53,1)\",\"rgba(0,132,212,1)\",\"rgba(0,178,123,1)\",\"rgba(0,105,127,1)\",\"rgba(125,39,43,1)\",\"rgba(68,162,18,1)\",\"rgba(186,158,0,1)\",\"rgba(110,48,59,1)\",\"rgba(50,94,61,1)\",\"rgba(40,137,41,1)\",\"rgba(120,30,33,1)\",\"rgba(99,139,0,1)\",\"rgba(26,27,32,1)\",\"rgba(228,124,0,1)\",\"rgba(131,35,48,1)\",\"rgba(131,127,65,1)\",\"rgba(84,110,13,1)\",\"rgba(97,31,34,1)\",\"rgba(48,130,44,1)\",\"rgba(102,39,46,1)\",\"rgba(122,119,12,1)\",\"rgba(110,118,0,1)\",\"rgba(59,110,61,1)\",\"rgba(151,41,49,1)\",\"rgba(0,150,88,1)\",\"rgba(87,59,57,1)\",\"rgba(29,150,60,1)\",\"rgba(0,220,190,1)\",\"rgba(74,87,134,1)\",\"rgba(139,142,0,1)\",\"rgba(0,106,133,1)\",\"rgba(0,133,46,1)\",\"rgba(78,128,62,1)\",\"rgba(0,108,130,1)\",\"rgba(0,151,46,1)\",\"rgba(0,144,55,1)\",\"rgba(76,113,30,1)\",\"rgba(83,28,41,1)\",\"rgba(0,114,168,1)\",\"rgba(59,38,43,1)\",\"rgba(76,150,40,1)\",\"rgba(105,138,53,1)\",\"rgba(101,131,0,1)\",\"rgba(185,102,18,1)\",\"rgba(159,89,24,1)\"],\"line\":{\"color\":[\"rgba(77,39,47,1)\",\"rgba(0,129,115,1)\",\"rgba(34,12,16,1)\",\"rgba(219,64,66,1)\",\"rgba(64,46,46,1)\",\"rgba(106,32,35,1)\",\"rgba(52,34,50,1)\",\"rgba(87,137,0,1)\",\"rgba(49,129,28,1)\",\"rgba(107,129,63,1)\",\"rgba(0,146,186,1)\",\"rgba(75,56,66,1)\",\"rgba(159,52,61,1)\",\"rgba(0,173,123,1)\",\"rgba(82,170,35,1)\",\"rgba(81,51,61,1)\",\"rgba(11,128,58,1)\",\"rgba(64,93,68,1)\",\"rgba(84,155,194,1)\",\"rgba(112,146,0,1)\",\"rgba(85,152,100,1)\",\"rgba(103,32,44,1)\",\"rgba(110,118,0,1)\",\"rgba(0,126,58,1)\",\"rgba(56,163,55,1)\",\"rgba(103,106,32,1)\",\"rgba(85,66,59,1)\",\"rgba(133,196,0,1)\",\"rgba(66,95,70,1)\",\"rgba(0,157,66,1)\",\"rgba(55,131,60,1)\",\"rgba(49,172,0,1)\",\"rgba(83,144,0,1)\",\"rgba(196,54,40,1)\",\"rgba(133,143,0,1)\",\"rgba(155,31,44,1)\",\"rgba(0,156,61,1)\",\"rgba(185,32,42,1)\",\"rgba(80,81,44,1)\",\"rgba(138,136,132,1)\",\"rgba(130,33,34,1)\",\"rgba(50,157,134,1)\",\"rgba(111,102,29,1)\",\"rgba(0,141,59,1)\",\"rgba(0,110,69,1)\",\"rgba(0,110,122,1)\",\"rgba(134,26,49,1)\",\"rgba(51,144,0,1)\",\"rgba(66,122,15,1)\",\"rgba(187,196,225,1)\",\"rgba(41,162,52,1)\",\"rgba(82,120,30,1)\",\"rgba(4,149,9,1)\",\"rgba(135,125,0,1)\",\"rgba(120,19,29,1)\",\"rgba(80,155,53,1)\",\"rgba(0,132,212,1)\",\"rgba(0,178,123,1)\",\"rgba(0,105,127,1)\",\"rgba(125,39,43,1)\",\"rgba(68,162,18,1)\",\"rgba(186,158,0,1)\",\"rgba(110,48,59,1)\",\"rgba(50,94,61,1)\",\"rgba(40,137,41,1)\",\"rgba(120,30,33,1)\",\"rgba(99,139,0,1)\",\"rgba(26,27,32,1)\",\"rgba(228,124,0,1)\",\"rgba(131,35,48,1)\",\"rgba(131,127,65,1)\",\"rgba(84,110,13,1)\",\"rgba(97,31,34,1)\",\"rgba(48,130,44,1)\",\"rgba(102,39,46,1)\",\"rgba(122,119,12,1)\",\"rgba(110,118,0,1)\",\"rgba(59,110,61,1)\",\"rgba(151,41,49,1)\",\"rgba(0,150,88,1)\",\"rgba(87,59,57,1)\",\"rgba(29,150,60,1)\",\"rgba(0,220,190,1)\",\"rgba(74,87,134,1)\",\"rgba(139,142,0,1)\",\"rgba(0,106,133,1)\",\"rgba(0,133,46,1)\",\"rgba(78,128,62,1)\",\"rgba(0,108,130,1)\",\"rgba(0,151,46,1)\",\"rgba(0,144,55,1)\",\"rgba(76,113,30,1)\",\"rgba(83,28,41,1)\",\"rgba(0,114,168,1)\",\"rgba(59,38,43,1)\",\"rgba(76,150,40,1)\",\"rgba(105,138,53,1)\",\"rgba(101,131,0,1)\",\"rgba(185,102,18,1)\",\"rgba(159,89,24,1)\"]}},\"textfont\":{\"color\":[\"rgba(77,39,47,1)\",\"rgba(0,129,115,1)\",\"rgba(34,12,16,1)\",\"rgba(219,64,66,1)\",\"rgba(64,46,46,1)\",\"rgba(106,32,35,1)\",\"rgba(52,34,50,1)\",\"rgba(87,137,0,1)\",\"rgba(49,129,28,1)\",\"rgba(107,129,63,1)\",\"rgba(0,146,186,1)\",\"rgba(75,56,66,1)\",\"rgba(159,52,61,1)\",\"rgba(0,173,123,1)\",\"rgba(82,170,35,1)\",\"rgba(81,51,61,1)\",\"rgba(11,128,58,1)\",\"rgba(64,93,68,1)\",\"rgba(84,155,194,1)\",\"rgba(112,146,0,1)\",\"rgba(85,152,100,1)\",\"rgba(103,32,44,1)\",\"rgba(110,118,0,1)\",\"rgba(0,126,58,1)\",\"rgba(56,163,55,1)\",\"rgba(103,106,32,1)\",\"rgba(85,66,59,1)\",\"rgba(133,196,0,1)\",\"rgba(66,95,70,1)\",\"rgba(0,157,66,1)\",\"rgba(55,131,60,1)\",\"rgba(49,172,0,1)\",\"rgba(83,144,0,1)\",\"rgba(196,54,40,1)\",\"rgba(133,143,0,1)\",\"rgba(155,31,44,1)\",\"rgba(0,156,61,1)\",\"rgba(185,32,42,1)\",\"rgba(80,81,44,1)\",\"rgba(138,136,132,1)\",\"rgba(130,33,34,1)\",\"rgba(50,157,134,1)\",\"rgba(111,102,29,1)\",\"rgba(0,141,59,1)\",\"rgba(0,110,69,1)\",\"rgba(0,110,122,1)\",\"rgba(134,26,49,1)\",\"rgba(51,144,0,1)\",\"rgba(66,122,15,1)\",\"rgba(187,196,225,1)\",\"rgba(41,162,52,1)\",\"rgba(82,120,30,1)\",\"rgba(4,149,9,1)\",\"rgba(135,125,0,1)\",\"rgba(120,19,29,1)\",\"rgba(80,155,53,1)\",\"rgba(0,132,212,1)\",\"rgba(0,178,123,1)\",\"rgba(0,105,127,1)\",\"rgba(125,39,43,1)\",\"rgba(68,162,18,1)\",\"rgba(186,158,0,1)\",\"rgba(110,48,59,1)\",\"rgba(50,94,61,1)\",\"rgba(40,137,41,1)\",\"rgba(120,30,33,1)\",\"rgba(99,139,0,1)\",\"rgba(26,27,32,1)\",\"rgba(228,124,0,1)\",\"rgba(131,35,48,1)\",\"rgba(131,127,65,1)\",\"rgba(84,110,13,1)\",\"rgba(97,31,34,1)\",\"rgba(48,130,44,1)\",\"rgba(102,39,46,1)\",\"rgba(122,119,12,1)\",\"rgba(110,118,0,1)\",\"rgba(59,110,61,1)\",\"rgba(151,41,49,1)\",\"rgba(0,150,88,1)\",\"rgba(87,59,57,1)\",\"rgba(29,150,60,1)\",\"rgba(0,220,190,1)\",\"rgba(74,87,134,1)\",\"rgba(139,142,0,1)\",\"rgba(0,106,133,1)\",\"rgba(0,133,46,1)\",\"rgba(78,128,62,1)\",\"rgba(0,108,130,1)\",\"rgba(0,151,46,1)\",\"rgba(0,144,55,1)\",\"rgba(76,113,30,1)\",\"rgba(83,28,41,1)\",\"rgba(0,114,168,1)\",\"rgba(59,38,43,1)\",\"rgba(76,150,40,1)\",\"rgba(105,138,53,1)\",\"rgba(101,131,0,1)\",\"rgba(185,102,18,1)\",\"rgba(159,89,24,1)\"]},\"line\":{\"color\":[\"rgba(77,39,47,1)\",\"rgba(0,129,115,1)\",\"rgba(34,12,16,1)\",\"rgba(219,64,66,1)\",\"rgba(64,46,46,1)\",\"rgba(106,32,35,1)\",\"rgba(52,34,50,1)\",\"rgba(87,137,0,1)\",\"rgba(49,129,28,1)\",\"rgba(107,129,63,1)\",\"rgba(0,146,186,1)\",\"rgba(75,56,66,1)\",\"rgba(159,52,61,1)\",\"rgba(0,173,123,1)\",\"rgba(82,170,35,1)\",\"rgba(81,51,61,1)\",\"rgba(11,128,58,1)\",\"rgba(64,93,68,1)\",\"rgba(84,155,194,1)\",\"rgba(112,146,0,1)\",\"rgba(85,152,100,1)\",\"rgba(103,32,44,1)\",\"rgba(110,118,0,1)\",\"rgba(0,126,58,1)\",\"rgba(56,163,55,1)\",\"rgba(103,106,32,1)\",\"rgba(85,66,59,1)\",\"rgba(133,196,0,1)\",\"rgba(66,95,70,1)\",\"rgba(0,157,66,1)\",\"rgba(55,131,60,1)\",\"rgba(49,172,0,1)\",\"rgba(83,144,0,1)\",\"rgba(196,54,40,1)\",\"rgba(133,143,0,1)\",\"rgba(155,31,44,1)\",\"rgba(0,156,61,1)\",\"rgba(185,32,42,1)\",\"rgba(80,81,44,1)\",\"rgba(138,136,132,1)\",\"rgba(130,33,34,1)\",\"rgba(50,157,134,1)\",\"rgba(111,102,29,1)\",\"rgba(0,141,59,1)\",\"rgba(0,110,69,1)\",\"rgba(0,110,122,1)\",\"rgba(134,26,49,1)\",\"rgba(51,144,0,1)\",\"rgba(66,122,15,1)\",\"rgba(187,196,225,1)\",\"rgba(41,162,52,1)\",\"rgba(82,120,30,1)\",\"rgba(4,149,9,1)\",\"rgba(135,125,0,1)\",\"rgba(120,19,29,1)\",\"rgba(80,155,53,1)\",\"rgba(0,132,212,1)\",\"rgba(0,178,123,1)\",\"rgba(0,105,127,1)\",\"rgba(125,39,43,1)\",\"rgba(68,162,18,1)\",\"rgba(186,158,0,1)\",\"rgba(110,48,59,1)\",\"rgba(50,94,61,1)\",\"rgba(40,137,41,1)\",\"rgba(120,30,33,1)\",\"rgba(99,139,0,1)\",\"rgba(26,27,32,1)\",\"rgba(228,124,0,1)\",\"rgba(131,35,48,1)\",\"rgba(131,127,65,1)\",\"rgba(84,110,13,1)\",\"rgba(97,31,34,1)\",\"rgba(48,130,44,1)\",\"rgba(102,39,46,1)\",\"rgba(122,119,12,1)\",\"rgba(110,118,0,1)\",\"rgba(59,110,61,1)\",\"rgba(151,41,49,1)\",\"rgba(0,150,88,1)\",\"rgba(87,59,57,1)\",\"rgba(29,150,60,1)\",\"rgba(0,220,190,1)\",\"rgba(74,87,134,1)\",\"rgba(139,142,0,1)\",\"rgba(0,106,133,1)\",\"rgba(0,133,46,1)\",\"rgba(78,128,62,1)\",\"rgba(0,108,130,1)\",\"rgba(0,151,46,1)\",\"rgba(0,144,55,1)\",\"rgba(76,113,30,1)\",\"rgba(83,28,41,1)\",\"rgba(0,114,168,1)\",\"rgba(59,38,43,1)\",\"rgba(76,150,40,1)\",\"rgba(105,138,53,1)\",\"rgba(101,131,0,1)\",\"rgba(185,102,18,1)\",\"rgba(159,89,24,1)\"]},\"frame\":null}],\"highlight\":{\"on\":\"plotly_click\",\"persistent\":false,\"dynamic\":false,\"selectize\":false,\"opacityDim\":0.2,\"selected\":{\"opacity\":1},\"debounce\":0},\"shinyEvents\":[\"plotly_hover\",\"plotly_click\",\"plotly_selected\",\"plotly_relayout\",\"plotly_brushed\",\"plotly_brushing\",\"plotly_clickannotation\",\"plotly_doubleclick\",\"plotly_deselect\",\"plotly_afterplot\",\"plotly_sunburstclick\"],\"base_url\":\"https://plot.ly\"},\"evals\":[],\"jsHooks\":[]} If you play around with this enough, you‚Äôll realize that plotting all of your 3D data on a plot as individual points is kind of cumbersome when you have thousands of points; you can‚Äôt really tell which regions of your color space are more or less dense. It may better suit your purposes to cluster the data a bit first, and then plot the clusters:\nclusters \u0026lt;- extractClusters(getKMeanColors(img, color.space = \u0026quot;Lab\u0026quot;, ref.white = \u0026quot;D65\u0026quot;, n = 50, plotting = F)) colnames(clusters) \u0026lt;- c(\u0026quot;L\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;Pct\u0026quot;) # We can do this with a colordistance function... scatter3dclusters(clusters, color.space = \u0026quot;lab\u0026quot;, scaling = 100)  # we can also use scatter3D, with a bit of a hack to get different point sizes col_vector \u0026lt;- rgb(convertColor(clusters[ , 1:3], from = \u0026quot;Lab\u0026quot;, to = \u0026quot;sRGB\u0026quot;)) # make blank plot scatter3D(clusters$L, clusters$a, clusters$b, cex = 0, colkey = F, phi = 35, theta = 60, xlab = \u0026quot;L\u0026quot;, ylab = \u0026quot;a\u0026quot;, zlab = \u0026quot;b\u0026quot;) # set scale multiplier for point sizes scale \u0026lt;- 80 # add one point at a time, setting size with the cex argument for (i in 1:nrow(clusters)) { scatter3D(x = clusters$L[i], y = clusters$a[i], z = clusters$b[i], cex = clusters$Pct[i] * scale, pch = 19, alpha = 0.5, col = col_vector[i], add = TRUE) }  # or, we can just use plotly again plot_ly(data = clusters, x = ~L, y = ~a, z = ~b, type = \u0026quot;scatter3d\u0026quot;, mode = \u0026quot;markers\u0026quot;, color = I(col_vector), # this is a bit of a hack and you'll get a warning... colors = col_vector, size = ~Pct)   {\"x\":{\"visdat\":{\"948a2bab3c7f\":[\"function () \",\"plotlyVisDat\"]},\"cur_data\":\"948a2bab3c7f\",\"attrs\":{\"948a2bab3c7f\":{\"x\":{},\"y\":{},\"z\":{},\"mode\":\"markers\",\"color\":[\"#647933\",\"#732429\",\"#986516\",\"#832128\",\"#232023\",\"#138233\",\"#943E1F\",\"#17AEAB\",\"#0C8864\",\"#499535\",\"#384D39\",\"#573F3B\",\"#9F8008\",\"#047579\",\"#077C6D\",\"#108DB0\",\"#BA2E2C\",\"#06667C\",\"#0DD7B4\",\"#86B20D\",\"#8B8784\",\"#5F780B\",\"#766D2A\",\"#C06012\",\"#1860A9\",\"#62512B\",\"#B1A206\",\"#545D2C\",\"#37CA7A\",\"#22587E\",\"#3A9610\",\"#55BC26\",\"#66242C\",\"#473037\",\"#C34622\",\"#038E51\",\"#1EA43A\",\"#C17C08\",\"#4B8407\",\"#10753B\",\"#758F07\",\"#15AA7C\",\"#265F37\",\"#7E1C32\",\"#119846\",\"#9C212B\",\"#898609\",\"#582531\",\"#5E9706\",\"#3F7624\"],\"size\":{},\"colors\":[\"#647933\",\"#732429\",\"#986516\",\"#832128\",\"#232023\",\"#138233\",\"#943E1F\",\"#17AEAB\",\"#0C8864\",\"#499535\",\"#384D39\",\"#573F3B\",\"#9F8008\",\"#047579\",\"#077C6D\",\"#108DB0\",\"#BA2E2C\",\"#06667C\",\"#0DD7B4\",\"#86B20D\",\"#8B8784\",\"#5F780B\",\"#766D2A\",\"#C06012\",\"#1860A9\",\"#62512B\",\"#B1A206\",\"#545D2C\",\"#37CA7A\",\"#22587E\",\"#3A9610\",\"#55BC26\",\"#66242C\",\"#473037\",\"#C34622\",\"#038E51\",\"#1EA43A\",\"#C17C08\",\"#4B8407\",\"#10753B\",\"#758F07\",\"#15AA7C\",\"#265F37\",\"#7E1C32\",\"#119846\",\"#9C212B\",\"#898609\",\"#582531\",\"#5E9706\",\"#3F7624\"],\"alpha_stroke\":1,\"sizes\":[10,100],\"spans\":[1,20],\"type\":\"scatter3d\"}},\"layout\":{\"margin\":{\"b\":40,\"l\":60,\"t\":25,\"r\":10},\"scene\":{\"xaxis\":{\"title\":\"L\"},\"yaxis\":{\"title\":\"a\"},\"zaxis\":{\"title\":\"b\"}},\"hovermode\":\"closest\",\"showlegend\":false},\"source\":\"A\",\"config\":{\"showSendToCloud\":false},\"data\":[{\"x\":[47.6470370380395,26.9343668030093,47.1828825841296,29.6773078450699,12.7045820506114,47.424072153912,37.7095435680787,64.3966358719047,50.2170710701797,55.2008575013163,30.5639393862333,29.2352057210328,54.8739847444633,44.21651687503,46.4348311991777,54.3461739170174,42.2864967235475,39.4002815788575,77.246141494701,67.3417368584501,56.4821125357197,46.7293021620499,45.4986153446182,51.5290761538363,40.1338361320406,35.3775725076101,65.7951807953912,37.6049924843794,72.5005589738049,35.5332956130365,54.909869921715,68.0826258130497,24.7407170414244,22.5787090735333,47.2231676738661,51.6978881209399,58.9315019517576,57.9255190148564,49.6384118056201,42.7699221303017,55.5967406937468,61.8862757522115,35.7827664244431,28.3085165518734,55.1722752062099,34.8245048991748,54.4721552035387,22.5158972154844,56.5773369142028,44.269889046976],\"y\":[-19.1560055874448,35.1558839259183,14.2720406280373,41.9759780318741,2.27151473468494,-46.9672270333645,34.3138626384862,-36.1794957895637,-40.2015036246707,-42.360763899665,-13.1006131883921,9.63830700679229,2.01930745644207,-25.3929355968667,-32.9400403387384,-18.7144718129058,55.1505786880039,-16.2512192026847,-52.1150378079515,-35.0058101398964,1.02962325971967,-23.1977287309345,-5.20162909915775,34.3707882925485,6.26556465863796,1.71232485126426,-8.39391101221517,-11.537025012239,-56.2902446947673,-4.37777177199427,-49.6422187683071,-55.1756294819106,30.2241914435395,11.7955865367038,48.1326705218909,-47.3050354036041,-56.1539990811367,19.1817983458343,-37.485801469206,-41.0176083687218,-25.7079300352572,-47.2926881095034,-28.8228745220873,42.6000075381491,-52.123231334113,50.0622436786647,-11.744290691161,24.877420489759,-38.5316644028869,-33.7940092938693],\"z\":[35.0345104570875,15.8418904092597,48.9346846157969,20.9249840908074,-1.78570914036779,33.9657948063168,36.0165415746418,-9.12817187084792,10.7727716382048,42.0852089437363,9.12095630563548,6.53578709802711,58.7122851209248,-10.4896224844523,0.31534768082993,-27.1244338341843,35.7715089466191,-19.564988924393,5.09492563363152,66.8339063421687,1.77215759159408,49.418203672323,37.6199540518151,55.9747127260182,-45.4109435932669,24.7964325796627,67.9103022988535,26.7723537600718,28.8802186644586,-26.5501909597621,54.4569417630617,61.1975442753346,10.9134354860685,-0.242929238594548,46.7112900443923,23.6139098568036,43.9314187088593,62.7749914938315,51.9201408757226,24.0782770255091,57.8980119441862,13.286134167394,17.2635276892329,12.5309090043427,33.8323009989432,26.1273787908098,57.374791997851,4.05616250233049,58.1589172091652,37.9475390129431],\"mode\":\"markers\",\"type\":\"scatter3d\",\"marker\":{\"color\":[\"rgba(100,121,51,1)\",\"rgba(115,36,41,1)\",\"rgba(152,101,22,1)\",\"rgba(131,33,40,1)\",\"rgba(35,32,35,1)\",\"rgba(19,130,51,1)\",\"rgba(148,62,31,1)\",\"rgba(23,174,171,1)\",\"rgba(12,136,100,1)\",\"rgba(73,149,53,1)\",\"rgba(56,77,57,1)\",\"rgba(87,63,59,1)\",\"rgba(159,128,8,1)\",\"rgba(4,117,121,1)\",\"rgba(7,124,109,1)\",\"rgba(16,141,176,1)\",\"rgba(186,46,44,1)\",\"rgba(6,102,124,1)\",\"rgba(13,215,180,1)\",\"rgba(134,178,13,1)\",\"rgba(139,135,132,1)\",\"rgba(95,120,11,1)\",\"rgba(118,109,42,1)\",\"rgba(192,96,18,1)\",\"rgba(24,96,169,1)\",\"rgba(98,81,43,1)\",\"rgba(177,162,6,1)\",\"rgba(84,93,44,1)\",\"rgba(55,202,122,1)\",\"rgba(34,88,126,1)\",\"rgba(58,150,16,1)\",\"rgba(85,188,38,1)\",\"rgba(102,36,44,1)\",\"rgba(71,48,55,1)\",\"rgba(195,70,34,1)\",\"rgba(3,142,81,1)\",\"rgba(30,164,58,1)\",\"rgba(193,124,8,1)\",\"rgba(75,132,7,1)\",\"rgba(16,117,59,1)\",\"rgba(117,143,7,1)\",\"rgba(21,170,124,1)\",\"rgba(38,95,55,1)\",\"rgba(126,28,50,1)\",\"rgba(17,152,70,1)\",\"rgba(156,33,43,1)\",\"rgba(137,134,9,1)\",\"rgba(88,37,49,1)\",\"rgba(94,151,6,1)\",\"rgba(63,118,36,1)\"],\"size\":[55.8780487804878,100,19.8780487804878,68.609756097561,46.8780487804878,56.0975609756098,24.2682926829268,18.5609756097561,57.1951219512195,52.1463414634146,31.5121951219512,50.390243902439,39.6341463414634,60.2682926829268,56.7560975609756,10.6585365853659,48.4146341463415,61.3658536585366,13.5121951219512,21.4146341463415,17.2439024390244,54.5609756097561,50.1707317073171,34.8048780487805,10,33.2682926829268,18.1219512195122,53.2439024390244,11.7560975609756,28.4390243902439,74.3170731707317,24.4878048780488,83.3170731707317,67.9512195121951,42.4878048780488,70.3658536585366,56.5365853658537,26.9024390243902,74.9756097560976,40.9512195121951,59.609756097561,19.4390243902439,29.0975609756098,32.390243902439,75.4146341463415,60.7073170731707,51.0487804878049,49.7317073170732,55.219512195122,52.5853658536585],\"sizemode\":\"area\",\"line\":{\"color\":[\"rgba(100,121,51,1)\",\"rgba(115,36,41,1)\",\"rgba(152,101,22,1)\",\"rgba(131,33,40,1)\",\"rgba(35,32,35,1)\",\"rgba(19,130,51,1)\",\"rgba(148,62,31,1)\",\"rgba(23,174,171,1)\",\"rgba(12,136,100,1)\",\"rgba(73,149,53,1)\",\"rgba(56,77,57,1)\",\"rgba(87,63,59,1)\",\"rgba(159,128,8,1)\",\"rgba(4,117,121,1)\",\"rgba(7,124,109,1)\",\"rgba(16,141,176,1)\",\"rgba(186,46,44,1)\",\"rgba(6,102,124,1)\",\"rgba(13,215,180,1)\",\"rgba(134,178,13,1)\",\"rgba(139,135,132,1)\",\"rgba(95,120,11,1)\",\"rgba(118,109,42,1)\",\"rgba(192,96,18,1)\",\"rgba(24,96,169,1)\",\"rgba(98,81,43,1)\",\"rgba(177,162,6,1)\",\"rgba(84,93,44,1)\",\"rgba(55,202,122,1)\",\"rgba(34,88,126,1)\",\"rgba(58,150,16,1)\",\"rgba(85,188,38,1)\",\"rgba(102,36,44,1)\",\"rgba(71,48,55,1)\",\"rgba(195,70,34,1)\",\"rgba(3,142,81,1)\",\"rgba(30,164,58,1)\",\"rgba(193,124,8,1)\",\"rgba(75,132,7,1)\",\"rgba(16,117,59,1)\",\"rgba(117,143,7,1)\",\"rgba(21,170,124,1)\",\"rgba(38,95,55,1)\",\"rgba(126,28,50,1)\",\"rgba(17,152,70,1)\",\"rgba(156,33,43,1)\",\"rgba(137,134,9,1)\",\"rgba(88,37,49,1)\",\"rgba(94,151,6,1)\",\"rgba(63,118,36,1)\"]}},\"textfont\":{\"color\":[\"rgba(100,121,51,1)\",\"rgba(115,36,41,1)\",\"rgba(152,101,22,1)\",\"rgba(131,33,40,1)\",\"rgba(35,32,35,1)\",\"rgba(19,130,51,1)\",\"rgba(148,62,31,1)\",\"rgba(23,174,171,1)\",\"rgba(12,136,100,1)\",\"rgba(73,149,53,1)\",\"rgba(56,77,57,1)\",\"rgba(87,63,59,1)\",\"rgba(159,128,8,1)\",\"rgba(4,117,121,1)\",\"rgba(7,124,109,1)\",\"rgba(16,141,176,1)\",\"rgba(186,46,44,1)\",\"rgba(6,102,124,1)\",\"rgba(13,215,180,1)\",\"rgba(134,178,13,1)\",\"rgba(139,135,132,1)\",\"rgba(95,120,11,1)\",\"rgba(118,109,42,1)\",\"rgba(192,96,18,1)\",\"rgba(24,96,169,1)\",\"rgba(98,81,43,1)\",\"rgba(177,162,6,1)\",\"rgba(84,93,44,1)\",\"rgba(55,202,122,1)\",\"rgba(34,88,126,1)\",\"rgba(58,150,16,1)\",\"rgba(85,188,38,1)\",\"rgba(102,36,44,1)\",\"rgba(71,48,55,1)\",\"rgba(195,70,34,1)\",\"rgba(3,142,81,1)\",\"rgba(30,164,58,1)\",\"rgba(193,124,8,1)\",\"rgba(75,132,7,1)\",\"rgba(16,117,59,1)\",\"rgba(117,143,7,1)\",\"rgba(21,170,124,1)\",\"rgba(38,95,55,1)\",\"rgba(126,28,50,1)\",\"rgba(17,152,70,1)\",\"rgba(156,33,43,1)\",\"rgba(137,134,9,1)\",\"rgba(88,37,49,1)\",\"rgba(94,151,6,1)\",\"rgba(63,118,36,1)\"],\"size\":[55.8780487804878,100,19.8780487804878,68.609756097561,46.8780487804878,56.0975609756098,24.2682926829268,18.5609756097561,57.1951219512195,52.1463414634146,31.5121951219512,50.390243902439,39.6341463414634,60.2682926829268,56.7560975609756,10.6585365853659,48.4146341463415,61.3658536585366,13.5121951219512,21.4146341463415,17.2439024390244,54.5609756097561,50.1707317073171,34.8048780487805,10,33.2682926829268,18.1219512195122,53.2439024390244,11.7560975609756,28.4390243902439,74.3170731707317,24.4878048780488,83.3170731707317,67.9512195121951,42.4878048780488,70.3658536585366,56.5365853658537,26.9024390243902,74.9756097560976,40.9512195121951,59.609756097561,19.4390243902439,29.0975609756098,32.390243902439,75.4146341463415,60.7073170731707,51.0487804878049,49.7317073170732,55.219512195122,52.5853658536585]},\"error_y\":{\"width\":[]},\"error_x\":{\"width\":[]},\"line\":{\"color\":[\"rgba(100,121,51,1)\",\"rgba(115,36,41,1)\",\"rgba(152,101,22,1)\",\"rgba(131,33,40,1)\",\"rgba(35,32,35,1)\",\"rgba(19,130,51,1)\",\"rgba(148,62,31,1)\",\"rgba(23,174,171,1)\",\"rgba(12,136,100,1)\",\"rgba(73,149,53,1)\",\"rgba(56,77,57,1)\",\"rgba(87,63,59,1)\",\"rgba(159,128,8,1)\",\"rgba(4,117,121,1)\",\"rgba(7,124,109,1)\",\"rgba(16,141,176,1)\",\"rgba(186,46,44,1)\",\"rgba(6,102,124,1)\",\"rgba(13,215,180,1)\",\"rgba(134,178,13,1)\",\"rgba(139,135,132,1)\",\"rgba(95,120,11,1)\",\"rgba(118,109,42,1)\",\"rgba(192,96,18,1)\",\"rgba(24,96,169,1)\",\"rgba(98,81,43,1)\",\"rgba(177,162,6,1)\",\"rgba(84,93,44,1)\",\"rgba(55,202,122,1)\",\"rgba(34,88,126,1)\",\"rgba(58,150,16,1)\",\"rgba(85,188,38,1)\",\"rgba(102,36,44,1)\",\"rgba(71,48,55,1)\",\"rgba(195,70,34,1)\",\"rgba(3,142,81,1)\",\"rgba(30,164,58,1)\",\"rgba(193,124,8,1)\",\"rgba(75,132,7,1)\",\"rgba(16,117,59,1)\",\"rgba(117,143,7,1)\",\"rgba(21,170,124,1)\",\"rgba(38,95,55,1)\",\"rgba(126,28,50,1)\",\"rgba(17,152,70,1)\",\"rgba(156,33,43,1)\",\"rgba(137,134,9,1)\",\"rgba(88,37,49,1)\",\"rgba(94,151,6,1)\",\"rgba(63,118,36,1)\"]},\"frame\":null}],\"highlight\":{\"on\":\"plotly_click\",\"persistent\":false,\"dynamic\":false,\"selectize\":false,\"opacityDim\":0.2,\"selected\":{\"opacity\":1},\"debounce\":0},\"shinyEvents\":[\"plotly_hover\",\"plotly_click\",\"plotly_selected\",\"plotly_relayout\",\"plotly_brushed\",\"plotly_brushing\",\"plotly_clickannotation\",\"plotly_doubleclick\",\"plotly_deselect\",\"plotly_afterplot\",\"plotly_sunburstclick\"],\"base_url\":\"https://plot.ly\"},\"evals\":[],\"jsHooks\":[]} ","date":1618272000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1618329969,"objectID":"5354f59d6f9387f598b2da8cfa7e773f","permalink":"/post/modifying-pixel-plots/","publishdate":"2021-04-13T00:00:00Z","relpermalink":"/post/modifying-pixel-plots/","section":"post","summary":"How to make prettier, more flexible plots of pixels in color space.","tags":["colordistance","color","r packages","plotting"],"title":"Modifying pixel plots","type":"post"},{"authors":["Hannah Weller"],"categories":null,"content":" Create your slides in Markdown - click the Slides button to check out the example.   Supplementary notes can be added here, including code, math, and images.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"/project/external-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/external-project/","section":"project","summary":"An example of linking directly to an external project website using `external_link`.","tags":["Demo"],"title":"External Project","type":"project"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"8f66d660a9a2edc2d08e68cc30f701f7","permalink":"/project/internal-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/internal-project/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Internal Project","type":"project"},{"authors":["Hannah Weller","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Create your slides in Markdown - click the Slides button to check out the example.   Supplementary notes can be added here, including code, math, and images.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["Hannah Weller","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Create your slides in Markdown - click the Slides button to check out the example.   Supplementary notes can be added here, including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example conference paper","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f26b5133c34eec1aa0a09390a36c2ade","permalink":"/admin/config.yml","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/admin/config.yml","section":"","summary":"","tags":null,"title":"","type":"wowchemycms"}]